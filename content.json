{"meta":{"title":"Applehater","subtitle":"developer ? operator","description":"nothing","author":"Zohar Hou","url":"https://zh-h.github.io"},"pages":[{"title":"","date":"2019-10-26T21:49:24.149Z","updated":"2019-10-26T21:49:24.149Z","comments":true,"path":"README.html","permalink":"https://zh-h.github.io/README.html","excerpt":"","text":"applehater.cn"},{"title":"","date":"2019-10-26T21:49:24.161Z","updated":"2019-10-26T21:49:24.161Z","comments":true,"path":"who-weibo.html","permalink":"https://zh-h.github.io/who-weibo.html","excerpt":"","text":"谁是 po 主？ 微博图片地址： 查找 微博主页： ? function decodeBase62(number) { var alphabet = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' var out = 0 var len = number.length - 1 for (var t = 0; t"},{"title":"about","date":"2016-04-25T15:52:02.000Z","updated":"2019-10-26T21:49:24.161Z","comments":true,"path":"about/index.html","permalink":"https://zh-h.github.io/about/index.html","excerpt":"","text":"本站历程域名注册在 2014-07-28 运行在虚拟主机，使用Wordpress程序， 后使用过 GitHub 上Star最多的 Java 编写的博客程序 Solo， 也曾在运行在公有云，使用Typecho，由PHP7解析运行， 现在使用 Hexo 在 Github Pages 上发布博客（续费不起服务器），静态页面节省资源，对搜索引擎也更友好。 使用一个小工具可以将 Typecho 的文章批量转移为 Hexo： docker-typecho 个人介绍本人目前专注于后端开发，趋向 Java、Python 等编程语言。 在某物联网平台公司实习半年，作为 Java 开发工程师，期间接触到不少物联网的应用，包括：规则引擎、实时大数据、MQTT和X-Service等。 现在某云存储公司工作，任职是开发运维，主要职责是自动化运维系统的开发，包括：CMDB、监控告警平台和容器编排系统等。 我的 GitHub 你可以通过邮件 zh.h#outlook.com (把#替换成@) 或者微博 weibo.com/u/3888714809 联系我。 我们可以一同探讨领域内话题。另外的话工作邀请也是可以接受的。 ToDoList以下是我的短期内的技能掌握计划： 稳固 JAVA 基础：精通多线程编程，掌握常用的设计模式；熟悉 JVM ，包括内存模型、类加载机制以及性能优化； 精通服务端编程：精通 Netty、Spring；熟悉前端开发，熟悉 web 开发流程中各个角色和工作内容，向全栈发展； 熟悉 Web 服务器部署、配置及工作原理：Nginx、Apache、Tomcat等； 培养良好的软件工程知识和编码规范意识，精通软件分层设计，微服务的拆分； 精通关系型数据库设计及 SQL；熟悉常见的一些解决方案及其原理：单点登录、分布式缓存、分布式存储、SOA、RPC、全文检索、消息中间件，负载均衡、连接池、nosql、流计算等； 熟悉 Linux 操作系统，Linux 系统编程；熟练使用 Git、Jenkins等版本控制持续集成工具； 版权说明本站是我用来随便记录原创东东的，也会存放一些自己写的实验品。 除非单独说明，个人转载这里的原创内容，请遵循「署名 4.0 国际（CC BY 4.0）」的创作共享协议；只要在使用时署名，那么使用者可以对本站所有原创内容进行转载、节选、混编、二次创作，允许商业性使用。"},{"title":"links","date":"2016-04-25T15:52:02.000Z","updated":"2019-10-26T21:49:24.161Z","comments":true,"path":"links/index.html","permalink":"https://zh-h.github.io/links/index.html","excerpt":"","text":"站点 链接 Data Structure Visualizations http://www.cs.usfca.edu/~galles/visualization/Algorithms.html Relyn http://relyn.cn/ JUST SOMETHING http://blog.vincentzhong.cn/ Jing’s Blog http://www.iamlj.com/ 花開未央 http://sizheng.org/ 胡旭博客 http://www.ihuxu.com/ Gzp http://www.elfgzp.cn/ 敲代码守机房的 https://sqzryang.com/ ridog http://md.ridog.me/ Vincent Zhong https://wax8280.github.io 咄咄369 http://duoduo369.com/"},{"title":"tags","date":"2017-08-08T06:29:32.000Z","updated":"2019-10-26T21:49:24.161Z","comments":false,"path":"tags/index.html","permalink":"https://zh-h.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"HTTP 请求 gzip 解压","slug":"2018/04/10/gzip-request-deompress","date":"2018-04-09T16:00:00.000Z","updated":"2019-10-26T21:49:24.154Z","comments":true,"path":"2018/04/10/2018/04/10/gzip-request-deompress/","link":"","permalink":"https://zh-h.github.io/2018/04/10/2018/04/10/gzip-request-deompress/","excerpt":"","text":"实际的 Web 项目中，会存在请求正文非常大的场景，例如发表长篇博客，提大量流水记录等等。这些数据如果能在本地压缩后再提交，就可以节省网络流量、减少传输时间。 一般采用的压缩方式是 gzip 请求正文会被gzip压缩过进行二进制传输，而 HTTP 头部依然是原始的文本，根据协议需要在头部注明编码 Content-Encoding: gzip 在服务端接收到请求后，如果支持这种格式的压缩，会把请求正文进行解压再处理。 参考《如何压缩 HTTP 请求正文》 解压 gzip 请求JavaJava 内置了解压缩的流， 使用流的单项管道模式，可以把 gzip 的输入流，包装成原始的输入流。 123ByteArrayInputStream is = new ByteArrayInputStream(someGzipBytes) // 放入压缩后的流GzipInputStream gis = new GzipInputStream(is)String content = gis.text 翻看了一遍 Spring 的接口实现，实在没有找到合适的方法进行httpServletRequset.inputStream的替换。使用自定义的MessageConverter也是比较麻烦，需要把原本的配置覆盖替换，不得知对其他转换器的影响。 另外一种方法就是使用 Servlet API 的 Filter 进行处理，在获取到 gzip 的请求正文时对他进行解压。GunzipFilter.groovy 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * 处理gzip压缩过的请求体 * &lt;p&gt; * 使用 web.xml 配置 filter * Spring Boot 需要在主类使用 @ServletComponentScan 才能加载 */@WebFilter(filterName = \"gunzipFilter\", urlPatterns = \"/*\")public class GunzipFilter implements Filter &#123; public static final Logger LOGGER = LoggerFactory.getLogger(GunzipFilter.class); @Override public void init(FilterConfig filterConfig) throws ServletException &#123; LOGGER.info(\"gunzip filter init\"); &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest; String requestURI = httpServletRequest.getRequestURI(); LOGGER.info(\"request uri: &#123;&#125; Content-Encoding: &#123;&#125;\", requestURI, httpServletRequest.getHeader(\"Content-Encoding\")); if (\"/\".equals(requestURI)) &#123; LOGGER.info(\"process gzip request\"); httpServletRequest = new GunzipInputStreamWrapper(httpServletRequest); &#125; filterChain.doFilter(httpServletRequest, servletResponse); &#125; @Override public void destroy() &#123; &#125; static class GunzipInputStreamWrapper extends HttpServletRequestWrapper &#123; private ServletInputStream newServletInputStream; public GunzipInputStreamWrapper(HttpServletRequest request) &#123; super(request); &#125; @Override public ServletInputStream getInputStream() throws IOException &#123; if (newServletInputStream == null) &#123; ServletInputStream servletInputStream = super.getInputStream(); GZIPInputStream gzipInputStream = new GZIPInputStream(servletInputStream); newServletInputStream = new ServletInputStream() &#123; @Override public boolean isFinished() &#123; return true; &#125; @Override public boolean isReady() &#123; return true; &#125; @Override public void setReadListener(ReadListener readListener) &#123;&#125; @Override public int read() throws IOException &#123; return gzipInputStream.read(); &#125; &#125;; &#125; return newServletInputStream; &#125; &#125;&#125; OpenRestyOpenResty 可以通过使用 Lua 书写逻辑，可以导入使用 Lua 的类库，也可以通过 FFI 调用 C 语言编写的动态链接库。 需要下载 Lua 的 FFI zlib 库，然后通过 lua 脚本导入。 下载 https://github.com/luapower/zlib/archive/master.tar.gz 解压master.tar.gz 将linux64/libz.so zlib_h.lua zlib.lua复制到/usr/local/openresty/lualib/ 在/usr/local/openresty/lualib/创建gunzip.lua文件 在文件中输入 1234567891011121314151617181920212223242526272829303132333435363738394041local ffi = require &quot;ffi&quot;local zlib = require &quot;zlib&quot;local function reader(s) local done return function() if done then return end done = true return s endendlocal function writer() local t = &#123;&#125; return function(data, sz) if not data then return table.concat(t) end t[#t + 1] = ffi.string(data, sz) endendlocal encoding = ngx.req.get_headers()[&apos;Content-Encoding&apos;]ngx.log(ngx.INFO, &quot;encoding: &quot;..encoding)if encoding == &apos;gzip&apos; or encoding == &apos;deflate&apos; or encoding == &apos;deflate-raw&apos; then ngx.req.clear_header(&apos;Content-Encoding&apos;); ngx.req.read_body() local body = ngx.req.get_body_data() if body then ngx.log(ngx.INFO, &quot;unzip body&quot;) local write = writer() local map = &#123; gzip = &apos;gzip&apos;, deflate = &apos;zlib&apos;, [&apos;deflate-raw&apos;] = &apos;deflate&apos; &#125; local format = map[encoding] zlib.inflate(reader(body), write, nil, format) ngx.req.set_body_data(write()) end 编辑/usr/local/openresty/nginx/conf/nginx.conf在server块插入一下内容 1234567# call request body to lua contextlocation / &#123; # 非常重要，否则大文件解压因为被放到文件里导致读取的时候乱码 client_body_buffer_size 2048k; access_by_lua_file /usr/local/openresty/lualib/resty/gunzip.lua; proxy_pass http://192.168.150.226:8800; &#125; /usr/local/openresty/nginx/sbin/nginx -s reload 重载更新脚本。 OpenResty 映射对应需要请求的 URL 然后在对应的处理或者转发前执行 Lua 脚本，Lua 脚本判断请求类型读取请求体，并且使用 zlib 将其解压，然后再写回请求体，最后再把 Content-Encoding 清除，放置后端再做错误处理。 使用 gzip 压缩请求CURL先用 gzip 工具压缩，然后 curl 命令行工具支持提交 gzip 的文件。12echo \"&#123;\\\"msg\\\":\\\"hello\\\"&#125;\" | gzip -c &gt; data.txt.gzcurl -v --data-binary @data.txt.gz -H'Content-Type: application/json charset=UTF-8' -H'Content-Encoding: gzip' -X POST http://localhost:8800 JavaJava 同样提供了内置的 gzip 工具类，可以使用 GzipOutputStream 将输出流替换成压缩过的输出流，然后将压缩后的流通过 Socket 提交。 OkHttP 提供自定义请求正文的方法，可以把请求正文的格式替换为 gzipGzipRequest.groovy123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566@Slf4jclass GzipRequest &#123; static final MediaType JSON = MediaType.parse(\"application/json charset=utf-8\") static final String CONTENT = new File('C:\\\\Users\\\\Administrator\\\\Documents\\\\data-flow.json').text static OkHttpClient client = new OkHttpClient.Builder() .addInterceptor(new GzipRequestInterceptor()) .build() /** * @param args */ public static void main(String[] args) &#123; String content = '''&#123;\"msg\":\"hello\"&#125;''' content = CONTENT RequestBody body = RequestBody.create(JSON, content) Request request = new Request.Builder() .url('http://localhost:8800/?name=age') .post(body) .build() Response response = client.newCall(request).execute() String responseBody = response.body().string() log.info(responseBody) &#125; final static class GzipRequestInterceptor implements Interceptor &#123; @Override public Response intercept(Chain chain) throws IOException &#123; Request originalRequest = chain.request() if (originalRequest.body() == null || originalRequest.header(\"Content-Encoding\") != null) &#123; return chain.proceed(originalRequest) &#125; Request compressedRequest = originalRequest.newBuilder() .header(\"Content-Encoding\", \"gzip\") .method(originalRequest.method(), gzip(originalRequest.body())) .build() return chain.proceed(compressedRequest) &#125; private RequestBody gzip(final RequestBody body) &#123; return new RequestBody() &#123; @Override public MediaType contentType() &#123; return body.contentType() &#125; @Override public long contentLength() &#123; return -1 // We don't know the compressed length in advance! &#125; @Override public void writeTo(BufferedSink sink) throws IOException &#123; BufferedSink gzipSink = Okio.buffer(new GzipSink(sink)) body.writeTo(gzipSink) gzipSink.close() &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"}],"tags":[]},{"title":"MongoDB MapReduce","slug":"2017/12/15/spring-data-mongo-map-reduce","date":"2017-12-14T16:00:00.000Z","updated":"2019-10-26T21:49:24.154Z","comments":true,"path":"2017/12/15/2017/12/15/spring-data-mongo-map-reduce/","link":"","permalink":"https://zh-h.github.io/2017/12/15/2017/12/15/spring-data-mongo-map-reduce/","excerpt":"","text":"MongoDB的MapReduce可以实现复杂的聚合统计功能，并能够分发到各个数据副本中执行能够快速处理大量的数据。需要实现map函数和reduce函数，map函数组合格式化属性实现创建对象属性的映射，map函数的结果作为reduce函数的参数，reduce函数可以做数据的计算。1// TODO","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zh-h.github.io/tags/Spring/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://zh-h.github.io/tags/MongoDB/"}]},{"title":"RefreshScope 生效条件","slug":"2017/12/10/spring-cloud-config-refresh-scope","date":"2017-12-09T16:00:00.000Z","updated":"2019-10-26T21:49:24.154Z","comments":true,"path":"2017/12/10/2017/12/10/spring-cloud-config-refresh-scope/","link":"","permalink":"https://zh-h.github.io/2017/12/10/2017/12/10/spring-cloud-config-refresh-scope/","excerpt":"","text":"Spring Cloud Config 更新配置Spring Cloud Netflix Bus是Spring Cloud的消息机制,当Git Repository 改变时,通过POST请求Config Server的/bus/refresh,Config Server 会从repository获取最新的信息并通过amqp传递给client,如图所示. https://segmentfault.com/img/bVAhXA?w=1429&h=580 Spring Cloud Bus的更新只对三种情况有效 @ConfigurationProperties @RefreshScope 日志级别 @ConfigurationProperties使用 Java 定义类匹配配置文件中的声明应用代码1234567891011121314151617@ConfigurationProperties(prefix='api')class Api&#123; String host Integer port&#125;class ApiService&#123; @Autowrired Api api @Autowired RestTemplate restTemplate def hello()&#123; restTemplate.getForObject(\"$&#123;api.host&#125;:$&#123;api.port&#125;\", String) &#125;&#125; 配置文件123api: host: 127.0.0.1 port: 6666 当配置中心更新了配置文件后，会通过消息通知客户端拉取新的配置，@ConfigurationProperties 注解的类会及时得到更新。 @RefreshScope如果涉及消息队列或者数据库连接的配置，就需要声明 @RefreshScope 声明 @RefreshScope 后如果使用了注入的 property 类或者使用 @Value(‘${a.b,c}’) 语法取配置，收到刷新配置的消息时，将重新初始化类。 12345678@Component@RefreshScope@RabbitHandler(queues=&apos;$&#123;rcs.mq.strategyResponse&#125;&apos;)class StrategyLisener&#123; void hander(String message)&#123; // TODO &#125;&#125; 刷新配置将会重新初始化这个类，并且监听的是新配置的队列名。","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"}],"tags":[{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://zh-h.github.io/tags/Spring-Cloud/"}]},{"title":"RabbitMQ 的消息属性说明","slug":"2017/12/1/rabbit-mq-properties","date":"2017-11-30T16:00:00.000Z","updated":"2019-10-26T21:49:24.154Z","comments":true,"path":"2017/12/01/2017/12/1/rabbit-mq-properties/","link":"","permalink":"https://zh-h.github.io/2017/12/01/2017/12/1/rabbit-mq-properties/","excerpt":"","text":"RabbitMQAMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 RabbiMQ RPC 应用MQ本身是基于异步的消息处理，前面的示例中所有的生产者（P）将消息发送到RabbitMQ后不会知道消费者（C）处理成功或者失败（甚至连有没有消费者来处理这条消息都不知道）。 但实际的应用场景中，我们很可能需要一些同步处理，需要同步等待服务端将我的消息处理完成后再进行下一步处理。这相当于RPC（Remote Procedure Call，远程过程调用）。在RabbitMQ中也支持RPC。 http://cdndiggerplus.b0.upaiyun.com/wp-files/2014/02/2014-2-21-9-59-04.png 客户端发送请求（消息）时，在消息的属性（MessageProperties，在AMQP协议中定义了14中properties，这些属性会随着消息一起发送）中设置两个值replyTo（一个Queue名称，用于告诉服务器处理完成后将通知我的消息发送到这个Queue中）和correlationId（此次请求的标识号，服务器处理完成后需要将此属性返还，客户端将根据这个id了解哪条请求被成功执行了或执行失败） 服务器端收到消息并处理 服务器端处理完消息后，将生成一条应答消息到replyTo指定的Queue，同时带上correlationId属性 客户端之前已订阅replyTo指定的Queue，从中收到服务器的应答消息后，根据其中的correlationId属性分析哪条请求被执行了，根据执行结果进行后续业务处理 RabbitMQ AMQP properties 规范在开发环境中，需要使用 RabbitMQ 的管理面板进行消息的模拟发送，契约规定了微服务相互间的序列化使用 JSON，但是陷入了苦恼之中。 在表单中填写 properties 为 ContentType:application/json 无效！Spring AMQP 依然会把消息当作默认的类型进行处理，也就是对象流！点击源码一步步跳转深入发现，解析 properties 键值对的过程中，键并不是类似于 HTTP 的 Header 使用连字符，而是使用下划线，并且是小写！ 就是 content_type:application/json 才会当作 json 类型的消息进行解析。","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"}],"tags":[{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://zh-h.github.io/tags/RabbitMQ/"}]},{"title":"Spring Boot 使用内嵌 Mongo 进行测试","slug":"2017/11/26/Spring-Boot-With-Embedded-MongoDB-for-testing","date":"2017-11-25T16:00:00.000Z","updated":"2019-10-26T21:49:24.154Z","comments":true,"path":"2017/11/26/2017/11/26/Spring-Boot-With-Embedded-MongoDB-for-testing/","link":"","permalink":"https://zh-h.github.io/2017/11/26/2017/11/26/Spring-Boot-With-Embedded-MongoDB-for-testing/","excerpt":"","text":"如何进行数据库操作层的单元测试如何进行测试保证数据库操作层的语法正确，如果使用外部链接的数据库，不仅速度慢，数据定义麻烦而且违反了单元测试无外部依赖的规范。因此需要指定模拟的类库进行数据库操作，并且这个数据库是可以对语法进行检查。 Embedded MongoDB引入依赖build.gradle1234567dependencies &#123; compile \"org.mongodb:mongo-java-driver:2.12.2\" testCompile \"junit:junit:4.11\" testCompile \"de.flapdoodle.embed:de.flapdoodle.embed.mongo:1.46.0\"&#125; 脚手架MongodbBaseTest编写一个MongoBaseTest，这样所有需要Mongo的测试，可以继承这个类，就可以获取db了。 12345678910111213141516171819202122232425public class MongodbBaseTest &#123; private static final MongodStarter starter = MongodStarter.getDefaultInstance(); protected MongoClient mongo; protected DB db; private MongodExecutable mongodExecutable; private MongodProcess mongod; @Before public void setUp() throws Exception &#123; mongodExecutable = starter.prepare(new MongodConfigBuilder() .version(Version.Main.PRODUCTION) .net(new Net(12345, Network.localhostIsIPv6())).build()); mongod = mongodExecutable.start(); mongo = new MongoClient(\"localhost\", 12345); db = mongo.getDB(\"embedded-mongo\"); &#125; @After public void tearDown() throws Exception &#123; mongod.stop(); mongodExecutable.stop(); &#125;&#125; 编写UserTest12345678910111213141516171819202122public class UserTest extends MongodbBaseTest &#123; private DBCollection users; @Override @Before public void setUp() throws Exception &#123; super.setUp(); users = db.getCollection(\"users\"); &#125; @Test public void should_insert_and_get_user() &#123; final DBObject userDocument = new BasicDBObjectBuilder() .add(\"name\", \"kiwi\") .get(); users.insert(userDocument); final DBObject userDocumentFromDb = users.findOne(new BasicDBObject(\"_id\", userDocument.get(\"_id\"))); assertThat(userDocumentFromDb.get(\"name\"), is(\"kiwi\")); &#125;&#125; 自此单元测试中有关数据库层都是 Embedded MongoDB 进行模拟，这样保证语法验证的同时避免了外部资源的依赖。 Embedded MongoDB 与 Spring Test 结合","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://zh-h.github.io/tags/Spring-Boot/"}]},{"title":"Java Promise 实现","slug":"2017/11/17/java-promise","date":"2017-11-16T16:00:00.000Z","updated":"2019-10-26T21:49:24.154Z","comments":true,"path":"2017/11/17/2017/11/17/java-promise/","link":"","permalink":"https://zh-h.github.io/2017/11/17/2017/11/17/java-promise/","excerpt":"","text":"使用 ExcuteService可以根据自己的需要来创建壹個 ExecutorService ，也可以使用 Executors 工厂方法来创建壹個 ExecutorService 实例。这里有几個创建 ExecutorService 的例子：123ExecutorService executorService1 = Executors.newSingleThreadExecutor(); ExecutorService executorService2 = Executors.newFixedThreadPool(10); ExecutorService executorService3 = Executors.newScheduledThreadPool(10); ExecutorService 使用方法这里有几种不同的方式让你将任务委托给壹個 ExecutorService：12345execute(Runnable) submit(Runnable) submit(Callable) invokeAny(...) invokeAll(...) execute(Runnable)方法 execute(Runnable) 接收壹個 java.lang.Runnable 对象作为参数，并且以异步的方式执行它。如下是壹個使用 ExecutorService 执行 Runnable 的例子：123456789ExecutorService executorService = Executors.newSingleThreadExecutor(); executorService.execute(new Runnable() &#123; public void run() &#123; System.out.println(\"Asynchronous task\"); &#125; &#125;); executorService.shutdown(); 使用这种方式没有办法获取执行 Runnable 之后的结果，如果你希望获取运行之后的返回值，就必须使用 接收 Callable 参数的 execute() 方法，后者将会在下文中提到。 submit(Runnable)方法 submit(Runnable) 同样接收壹個 Runnable 的实现作为参数，但是会返回一个 Future 对象。这個 Future 对象可以用于判断 Runnable 是否结束执行。如下是壹個 ExecutorService 的 submit() 方法的例子：1234567Future future = executorService.submit(new Runnable() &#123; public void run() &#123; System.out.println(\"Asynchronous task\"); &#125; &#125;); //如果任务结束执行则返回 null System.out.println(\"future.get()=\" + future.get()); submit(Callable)方法 submit(Callable) 和方法 submit(Runnable) 比较类似，但是区别则在于它们接收不同的参数类型。Callable 的实例与 Runnable 的实例很类似，但是 Callable 的 call() 方法可以返回壹個结果。方法 Runnable.run() 则不能返回结果。 Callable 的返回值可以从方法 submit(Callable) 返回的 Future 对象中获取。如下是壹個 ExecutorService Callable 的样例：12345678Future future = executorService.submit(new Callable()&#123; public Object call() throws Exception &#123; System.out.println(\"Asynchronous Callable\"); return \"Callable Result\"; &#125; &#125;); System.out.println(\"future.get() = \" + future.get()); 上述样例代码会输出如下结果：12345678910111213141516171819202122232425ExecutorService executorService = Executors.newSingleThreadExecutor(); Set&lt;Callable&lt;String&gt;&gt; callables = new HashSet&lt;Callable&lt;String&gt;&gt;(); callables.add(new Callable&lt;String&gt;() &#123; public String call() throws Exception &#123; return \"Task 1\"; &#125; &#125;); callables.add(new Callable&lt;String&gt;() &#123; public String call() throws Exception &#123; return \"Task 2\"; &#125; &#125;); callables.add(new Callable&lt;String&gt;() &#123; public String call() throws Exception &#123; return \"Task 3\"; &#125; &#125;); String result = executorService.invoke(callables); System.out.println(\"result = \" + result); executorService.shutdown(); 如果把当中 Callable 的方法作为 Http 请求，那么就可以实现多个 HTTP 请求并发，一个请求异常整个调用异常，最后一个请求完成，整个调用完成。极大利用了 Java 的线程管理和网络带宽。","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"}],"tags":[{"name":"promise","slug":"promise","permalink":"https://zh-h.github.io/tags/promise/"}]},{"title":"Groovy 踩坑纪实","slug":"2017/11/10/groovy-hole","date":"2017-11-09T16:00:00.000Z","updated":"2019-10-26T21:49:24.154Z","comments":true,"path":"2017/11/10/2017/11/10/groovy-hole/","link":"","permalink":"https://zh-h.github.io/2017/11/10/2017/11/10/groovy-hole/","excerpt":"","text":"模式匹配取反Groovy 提供了简便的正则语法，可以很方便进行模式匹配和断言。 1def regex = ~'Groovy' 当Groovy运算符=〜在if和while语句（见第8章）中作为谓词（返回布尔值的表达式）出现时，左侧的String操作数与右侧的正则表达式操作数匹配。因此，以下每个都传递值true。 当定义正则表达式时，可以使用以下特殊字符: 有两个特殊的位置字符用于表示一行的开始和结束：caret（∧）和美元符号（$）。 正则表达式也可以包括量词。加号（+）表示一次或多次，应用于表达式的前一个元素。星号（*）用于表示零个或多个出现。问号（？）表示零或一次。 元字符{和}用于匹配前一个字符的特定数量的实例。 在正则表达式中，句点符号（。）可以表示任何字符。这被描述为通配符。 正则表达式可以包括字符类。一组字符可以作为简单的字符序列，包含在元字符[和]中，如[aeiou]中。对于字母或数字范围，可以使用[a-z]或[a-mA-M]中的短划线分隔符。字符类的补码由方括号内的前导插入符号表示，如[∧a-z]中所示，并表示除指定的字符以外的所有字符。 实例1234567'Groovy' =~ 'Groovy' 'Groovy' =~ 'oo' 'Groovy' ==~ 'Groovy' 'Groovy' ==~ 'oo' 'Groovy' =~ '∧G' ‘Groovy' =~ 'G$' ‘Groovy' =~ 'Gro*vy' 'Groovy' =~ 'Gro&#123;2&#125;vy' ATTENTIONS当使用一个等号 = 表示匹配，即 Matcher.matches()使用两个等号 == 表示取组，即 Mathcer.groups()如果需要取反条件，想当然使用 ! 插入表达式进行取反，结果是不会正常的。 使用 != 语法是无意义的，它表示 matches() 取反，matcher() 会一直有值， 因此不管什么样的输入都将返回False 正确做法:12&apos;machine-a&apos; =~~ &apos;machine-[abc]&apos; // 使用两个 ~~!(&apos;machine-a&apos; =~ &apos;machine-[abc]&apos;) // 表达式使用括号包围得返回值取反","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"}],"tags":[{"name":"Groovy","slug":"Groovy","permalink":"https://zh-h.github.io/tags/Groovy/"}]},{"title":"TypeSript 快速上手","slug":"2017/11/5/typescript-start-up","date":"2017-11-04T16:00:00.000Z","updated":"2019-10-26T21:49:24.154Z","comments":true,"path":"2017/11/05/2017/11/5/typescript-start-up/","link":"","permalink":"https://zh-h.github.io/2017/11/05/2017/11/5/typescript-start-up/","excerpt":"","text":"TypeScript 特性TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。TypeScript 通常先进与 ECAMScript 标准实现，如当前试验阶段的装饰器语法也会最先得到使用。 使用 TypeScript 带来的好处: 可以使用最新的 ES2017 语言特性 确定类型的智能代码提示,像单纯 Javascrit 还要人肉对比变量名拼写就十分痛苦。 编辑代码时具有及时错误检查功能，可以避免诸如输错函数名这种明显的错误 非常精准的代码重构功能 环境配置编译器使用 npm 全局安装 tsc。 tsconfig.json 配置文件每个 TypeScript 项目都需要一个 tsconfig.json 描述，告知编译器进行怎么样的处理： 123456789101112131415 &#123; \"compilerOptions\": &#123; \"module\": \"commonjs\", \"target\": \"es5\", \"outDir\": \"out\", \"lib\": [ \"es6\" ], \"sourceMap\": true, \"rootDir\": \"src\" &#125;, \"exclude\": [ \"node_modules\" ]&#125; 详细的字段更改请参考：https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/tsconfig.json.html 安装声明文件非 Typescript 编写的模块需要提供 tds 文件供编译器和 IDE 使用。Node.js 的 API 也要提供，使用npm I @types/node 进行安装。 创建 vscode 运行配置使用 vscode 对 Typescript 有很好的支持，如果需要执行单一的 Typescrit 源码还要另外设置运行配置。 123456789101112131415 &#123; \"type\": \"node\", \"request\": \"attach\", \"name\": \"Attach by Process ID\", \"processId\": \"$&#123;command:PickProcess&#125;\" &#125;, &#123; \"type\": \"node\", \"request\": \"launch\", \"name\": \"Launch Program\", \"program\": \"$&#123;file&#125;\", // 这个需要配置 \"outFiles\": [ \"$&#123;workspaceFolder&#125;/out/**/*.js\" // 这个 ]&#125; 如上面的配置，执行了一个任务在后台运行tsc -P -w实时监控文件变更并及时编译，运行配置为执行源码编译输出对应的 js 文件。 语法概览使用 Java 或者 C# 编程经验的人会对此非常熟悉，因为 Typescrit 的设计者就是 C# 的设计者。 类型声明与 Java 最大的不同可能就是类型声明是写在变量名之后。1234let a:string = 'a'function test(a:string)&#123; console.log(a)&#125; 方法声明包括输入参数和返回参数等，每个参数的顺序都是有意义的。123function call(cb:(a:string):void)&#123; cb('lalal')&#125; 基础类型以下是 TypeScript 中的几种基础类型： boolean为布尔值类型，如let isDone: Boolean = false number为数值类型，如let decimal: number = 6; string为字符串类型，如let color: string = ‘blue’ 数组类型，如let list: number[] = [ 1, 2, 3 ] 元组类型，如let x: [ string, number ] = [ “hello”, 10 ] 枚举类型，如enum Color { Red, Green, Blue }; let c: Color = Color.Green any为任意类型，如let notSure: any = 4; notSure = “maybe a string instead” void为空类型，如let unusable: void = undefined null和undefined never表示没有值的类型，如function error(message: string): never { throw new Error(message); } 多种类型可以用|隔开，比如number | string表示可以是number或string类型 接口（interface）以下是接口的几种常见形式：123456789101112131415161718192021222324// 定义具有 color 和 width 属性的对象interface SuperConfug &#123; color: string; width: number;&#125;// readonly 表示只读，不能对其属性进行重新赋值interface Point &#123; readonly x: number; readonly y: number;&#125;// ?表示属性是可选的，// [propName: string]: any 表示允许 obj[xxx] 这样的动态属性interface SquareConfig &#123; color?: string; width?: number; [propName: string]: any;&#125;// 函数接口interface SearchFunc &#123; (source: string, subString: string): boolean;&#125; 实际上 TypeScript 的接口还有很多种的表示形式，详细信息可以参考这里：TypeScript Hankbook - Interfaces函数 以下是几种函数接口的定义方式：1234567891011121314151617181920212223// 普通函数function add(a: number, b: number): number &#123; return a + b;&#125;// 函数参数function readFile(file: string, callback: (err: Error | null, data: Buffer) =&gt; void) &#123; fs.readFile(file, callback);&#125;// 通过 type 语句定义类型type CallbackFunction = (err: Error | null, data: Buffer) =&gt; void;function readFile(file: string, callback: CallbackFunction) &#123; fs.readFile(file, callback);&#125;// 通过 interface 语句来定义类型interface CallbackFunction &#123; (err: Error | null, data: Buffer): void;&#125;function readFile(file: string, callback: CallbackFunction) &#123; fs.readFile(file, callback);&#125; 以上几种定义方式有着微妙的差别，还是需要在深入实践 TypeScript 后才能合理地运用。详细信息可以参考这里：TypeScript Handbook - Functions类 TypeScript 的类定义跟 JavaScript 的定义方法类型一样，但是增加了public, private, protected, readonly等访问控制修饰符：12345678910111213141516171819class Person &#123; protected name: string; constructor(name: string) &#123; this.name = name; &#125;&#125;class Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name); this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125; 泛型TypeScript 的泛型和接口使得具备较强的类型检查能力的同时，很好地兼顾了 JavaScript 语言的动态特性。以下是使用泛型的简单例子：123456789101112function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;const map = new Map&lt;string, number&gt;();map.set(&apos;a&apos;, 123);function sleep(ms: number): Promise&lt;number&gt; &#123; return new Promise&lt;number&gt;((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve(ms), ms); &#125;);&#125;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://zh-h.github.io/categories/Javascript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://zh-h.github.io/tags/TypeScript/"}]},{"title":"Visual Studio Code 扩展/插件开发","slug":"2017/10/31/vscode-extension-developement","date":"2017-10-30T16:00:00.000Z","updated":"2019-10-26T21:49:24.153Z","comments":true,"path":"2017/10/31/2017/10/31/vscode-extension-developement/","link":"","permalink":"https://zh-h.github.io/2017/10/31/2017/10/31/vscode-extension-developement/","excerpt":"","text":"创建项目安装生成器1npm install -g yo generator-code 运行生成器1yo code yo code选择 New Extension (TypeScript),然后按照提示创建工程 运行扩展 使用vscode打开刚创建的项目 按F5，稍等下载依赖，然后会自动新打开一个用来调试的新窗口 ctrl+shit+p 运行 Hello World命令 扩展接口使用命令 编辑src/extension.ts添加一条新的命令 123context.subscriptions.push(vscode.commands.registerCommand('extension.connect',()=&gt;&#123; vscode.window.showInformationMessage('Connecting')&#125;)) 编辑package.json注册这条新命令 123456789\"commands\": [&#123; \"command\": \"extension.sayHello\", \"title\": \"Hello World\" &#125;, &#123; \"command\": \"extension.connect\", \"title\": \"Connect\" &#125;] 运行插件 ctrl+shit+p 输入命令 Hello World 激活该插件，只有激活插件后才能响应其他插件的命令，否则执行命令会报错123\"activationEvents\": [ \"onCommand:extension.sayHello\" // 在输入这个命令后会激活插件], 激活插件会触发src/extension.ts的 activate 方法123// this method is called when your extension is activated// your extension is activated the very first time the command is executedexport function activate(context: vscode.ExtensionContext) &#123;&#125; 因此插件的连接资源和其他全局使用的属性可以在这个方法后进行初始化 输入命令 Connect ，然后会弹出消息提示 Connecting，vscode 执行了这个命令内的代码块 激活插件的事件参考https://code.visualstudio.com/docs/extensionAPI/activation-events如工作区包含特定文件.PPYP.json就自动激活插件123\"activationEvents\": [ \"workspaceContains:.PPYP.json\"] 内置命令参考 https://code.visualstudio.com/docs/getstarted/settings#_settings-and-security123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354\"editor.action.toggleTabFocusMode\",\"workbench.action.debug.continue\",\"workbench.action.debug.pause\",\"workbench.action.debug.restart\",\"workbench.action.debug.run\",\"workbench.action.debug.start\",\"workbench.action.debug.stop\",\"workbench.action.focusActiveEditorGroup\",\"workbench.action.focusFirstEditorGroup\",\"workbench.action.focusSecondEditorGroup\",\"workbench.action.focusThirdEditorGroup\",\"workbench.action.navigateDown\",\"workbench.action.navigateLeft\",\"workbench.action.navigateRight\",\"workbench.action.navigateUp\",\"workbench.action.openNextRecentlyUsedEditorInGroup\",\"workbench.action.openPreviousRecentlyUsedEditorInGroup\",\"workbench.action.quickOpen\",\"workbench.action.quickOpenView\",\"workbench.action.showCommands\",\"workbench.action.terminal.clear\",\"workbench.action.terminal.copySelection\",\"workbench.action.terminal.deleteWordLeft\",\"workbench.action.terminal.deleteWordRight\",\"workbench.action.terminal.findWidget.history.showNext\",\"workbench.action.terminal.findWidget.history.showPrevious\",\"workbench.action.terminal.focus\",\"workbench.action.terminal.focusAtIndex1\",\"workbench.action.terminal.focusAtIndex2\",\"workbench.action.terminal.focusAtIndex3\",\"workbench.action.terminal.focusAtIndex4\",\"workbench.action.terminal.focusAtIndex5\",\"workbench.action.terminal.focusAtIndex6\",\"workbench.action.terminal.focusAtIndex7\",\"workbench.action.terminal.focusAtIndex8\",\"workbench.action.terminal.focusAtIndex9\",\"workbench.action.terminal.focusFindWidget\",\"workbench.action.terminal.focusNext\",\"workbench.action.terminal.focusPrevious\",\"workbench.action.terminal.hideFindWidget\",\"workbench.action.terminal.kill\",\"workbench.action.terminal.new\",\"workbench.action.terminal.paste\",\"workbench.action.terminal.runActiveFile\",\"workbench.action.terminal.runSelectedText\",\"workbench.action.terminal.scrollDown\",\"workbench.action.terminal.scrollDownPage\",\"workbench.action.terminal.scrollToBottom\",\"workbench.action.terminal.scrollToTop\",\"workbench.action.terminal.scrollUp\",\"workbench.action.terminal.scrollUpPage\",\"workbench.action.terminal.selectAll\",\"workbench.action.terminal.toggleTerminal\",\"workbench.action.togglePanel\" 设置 编辑package.json在 contribute 属性内添加 configuration 属性 1234567891011\"configuration\": &#123; \"type\": \"object\", \"title\": \"ppyy\", // 显示名称 \"properties\": &#123; \"ppyy.port\": &#123; \"type\": \"number\", // string,array,number 类型 \"default\": 5566, \"description\": \"Communication with ppyy-term`s socket server bind port\", \"scope\": \"resource\" &#125;&#125; 在extension.ts中使用 sayHello 命令获取配置属性 12345context.subscriptions.push(vscode.commands.registerCommand('extension.sayHello',()=&gt;&#123; let ppyyVscodeConfig = vscode.workspace.getConfiguration('ppyy') // 这个参数就是配置的前缀 console.log(JSON.stringify(ppyyVscodeConfig)) vscode.window.showInformationMessage('Hello World')&#125;)) 然后在编辑源码的 vscode 窗口的调试控制台将会输出{&quot;port&quot;:5566} 使用 Open Workspace Settings 命令打开设置编辑页面，对应的命令参数是workbench.action.openWorkspaceSettings 菜单 在package.json 的 contribute 属性中添加 menus 12345678\"menus\": &#123; \"editor/context\": [&#123; // 编辑器编辑内容内右键菜单呈现 \"when\": \"resourceLangId == python\", // 当符合条件的时候菜单才生效 \"command\": \"extension.sayHello\", \"alt\": \"resourceLangId == lua\", // 折这条件 \"group\": \"hello\" // 菜单上下文的分组 默认有navigation &#125;]&#125; 菜单上下文参考https://code.visualstudio.com/docs/extensionAPI/extension-points#_contributesmenus 1234567891011The global Command Palette - commandPaletteThe Explorer context menu - explorer/context 左侧文件树The editor context menu - editor/context 编辑器内容The editor title menu bar - editor/title 编辑器左侧...菜单The editor title context menu - editor/title/context 文件标题菜单The debug callstack view context menu - debug/callstack/contextThe SCM title menu - scm/titleSCM resource groups menus - scm/resourceGroup/contextSCM resources menus - scm/resource/contextThe View title menu - view/title 左侧视图标题The View item menu - view/item/context 菜单生效条件参考https://code.visualstudio.com/docs/getstarted/keybindings#_when-clause-contexts有常见的一下情况 12resourceLangId 当前编辑的文件语言，如 resourceLangId == luaresourceFilename 文件名 终端// TODO 状态栏栏目 创建一个状态栏目 1const item = vscode.window.createStatusBarIetm(StatusBarAlignment.LEFT, 100) // 数值越大越靠边 方法 123item.show() // 显示item.hide() // 隐藏item.despose() // 释放 变更他的属性 123item.text = 'lala' // 修改显示文字item.color = 'red' // 修改颜色item.tooltip = 'help me' // 指针停留显示的提示信息 使用图标支持使用$()语法来显示 [GitHub Octicon] (https://octicons.github.com/) 图标 12item.text = '$(pulse) haha' // 链接连接item.text = '$(repo-force-push) 100%' // 强推","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://zh-h.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://zh-h.github.io/tags/Javascript/"}]},{"title":"Kotlin objct 单例与反编译探究","slug":"2017/10/25/decomplie-kotlin-and-inspect-object-type","date":"2017-10-24T16:00:00.000Z","updated":"2019-10-26T21:49:24.153Z","comments":true,"path":"2017/10/25/2017/10/25/decomplie-kotlin-and-inspect-object-type/","link":"","permalink":"https://zh-h.github.io/2017/10/25/2017/10/25/decomplie-kotlin-and-inspect-object-type/","excerpt":"","text":"对 Kotlin 单例模式的语法糖感兴趣，了解一下怎么实现对应的 Java 如何实现最优化。 Java 单例模式参考 http://applehater.cn/2016/09/20/75/ object 对象表达式使用 Kotlin 的 object 对象表达式可以很方便创建一个单例模式。123456789object cat &#123; fun say() &#123; println(&quot;meow~&quot;) &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; cat.say() // 直接使用对象名称访问&#125; 对象表达式在我们使用的地方立即初始化并执行的。 对象声明是懒加载的，是在我们第一次访问时初始化的。 Java 实现1234567891011121314151617181920212223public final class cat &#123; public static final cat INSTANCE; public final void say() &#123; String var1 = &quot;meow~&quot;; System.out.println(var1); &#125; private cat() &#123; INSTANCE = (cat)this; &#125; static &#123; new cat(); &#125;&#125;public final class The_object_typeKt &#123; public static final void main(@NotNull String[] args) &#123; Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;); cat.INSTANCE.say(); &#125;&#125; 可见对象表达式使用了静态代码块构造的单例模式，静态代码块是在类初始化的时候进行的，而不像静态成员变量在类装载的时候就行初始化，可以实现延迟加载；利用 JVM 静态代码初始化的特性，可以实现同步的单例模式。 companion object 伴随对象Kotlin 没有提供静态方法，使用伴随对象可以获得近似静态成员访问的效果，但是实际上仍然是真正的成员实例。 123456789101112131415class AnimalProtectionOrganization&#123; fun say()&#123; println(&quot;protect!&quot;) &#125;&#125;class Dog&#123; companion object &#123; val APO = AnimalProtectionOrganization() &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; Dog.APO.say()&#125; 伴随对象在对应的类加载初始化，和静态变量的机制类似。 Java 实现123456789101112131415161718192021222324252627public final class Dog &#123; @NotNull private static final AnimalProtectionOrganization APO = new AnimalProtectionOrganization(); public static final Dog.Companion Companion = new Dog.Companion((DefaultConstructorMarker)null); public static final class Companion &#123; @NotNull public final AnimalProtectionOrganization getAPO() &#123; return Dog.APO; &#125; private Companion() &#123; &#125; // $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) &#123; this(); &#125; &#125;&#125;public final class The_object_typeKt &#123; public static final void main(@NotNull String[] args) &#123; Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;); Dog.Companion.getAPO().say(); &#125;&#125; 使用了内部嵌套类实现单例模式。 Kotlin 反编译为 Java 源码 使用IntelliJ IDEA 打开制定的 Kotlin 文件(需安装Kotlin插件)； 使用 Tools -&gt; Kotlin -&gt; Show Kotlin Bytecode； 使用 decompile 将 JVM 字节码转换为对应的 Java 源码； 然后你就可以探究一下 Kotlin 的语法糖是怎么在 Java 中实现。","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/tags/Java/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://zh-h.github.io/tags/Kotlin/"}]},{"title":"NodeMCU with MicroPython","slug":"2017/10/19/NodeMCU","date":"2017-10-18T16:00:00.000Z","updated":"2019-10-26T21:49:24.153Z","comments":true,"path":"2017/10/19/2017/10/19/NodeMCU/","link":"","permalink":"https://zh-h.github.io/2017/10/19/2017/10/19/NodeMCU/","excerpt":"","text":"刷入固件准备 使用 USB 连接 NodeMCU 到 PC 下载 MicroPython for ESP8266 的固件 下载安装 CP210x_Windows_Drivers 使用 pip 安装 esptool 和 ampy 擦除Flash 在设备管理器中找到串口连接串口号（比如 COM3） 运行esptool.py --port COM3 erase_flash把先前固件的数据都删掉，防止出现一些问题运行正确的话输出如下1234567891011$ esptool.py --port COM3 erase_flashesptool.py v2.1Connecting....Detecting chip type... ESP8266Chip is ESP8266Uploading stub...Running stub...Stub running...Erasing flash (this may take a while)...Chip erase completed successfully in 10.6sHard resetting... 刷入 运行esptool.py --port COM3 write_flash -fm qio 0x00000 esp8266-20170823-v1.9.2.bin默认的-fm写入模式是dio对于大于 4M 的 Flash 会有更好的兼容，但是速率受限。 multi I/O SPI设备是有从单一设备支持增加带宽或throughput的能力。相对于标准的串行Flash存储设备，一个dual I/O接口能够使能双倍的速率。quad I/O接口能提升throughput四次。 运行成功的输出如下 123456789101112131415161718$ esptool.py --port COM3 write_flash -fm qio 0x00000 esp8266-20170823-v1.9.2.bin8266-20170823-v1.9.2.binesptool.py v2.1Connecting....Detecting chip type... ESP8266Chip is ESP8266Uploading stub...Running stub...Stub running...Configuring flash size...Auto-detected Flash size: 4MBFlash params set to 0x0240Compressed 601136 bytes to 392067...Wrote 601136 bytes (392067 compressed) at 0x00000000 in 34.7 seconds (effective 138.7 kbit/s)...Hash of data verified.Leaving...Hard resetting... 按下板子的 RST 键重启 REPL REPL — 交互式解释器环境。R(read)、E(evaluate)、P(print)、L(loop)输入值，交互式解释器会读取输入内容并对它求值，再返回结果，并重复此过程。 Micropython 提供REPL，但是为了能够人机交互，需要其他的软件接收信号发送给开发板。 putty 设置串口号和波特率 设置串口号和波特率 设置其他参数 设置其他参数 打开连接1234567l▒\"rdr$r▒n▒▒▒▒▒oܟ▒▒#r▒▒b쏜#$▒#$▒▒l#$▒▒ln▒p&#123;l▒l▒▒|▒▒▒#4 ets_task(40100164, 3, 3fff837c, 4)OSError: [Errno 2] ENOENTMicroPython v1.9.2-8-gbf8f45cf on 2017-08-23; ESP module with ESP8266Type \"help()\" for more information.&gt;&gt;&gt; help()Welcome to MicroPython! ampyAdafruit MicroPython Tool 通过串口连接 MicroPython 单板的的工具，支持获取、罗列、删除、提交文件以及运行脚本的功能。 运行ampy --port COM3 get boot.py获取boot.py的内容12345678$ ampy --port COM3 get boot.py# This file is executed on every boot (including wake-boot from deepsleep)#import esp#esp.osdebug(None)import gc#import webrepl#webrepl.start()gc.collect() 或者设置终端的环境变量export AMPY_PORT=COM3(Windows CMD: set AMPY_PORT=COM3)指定端口1$ ampy get boot.py node-serialport一个 Node.js 库，支持Linux、Windows和MacOS，使用 Javascript 事件驱动编程，支持命令行打开模拟终端连接串口 罗列所有串口 12PS C:\\&gt;serialport-term.cmdCOM3 USB\\VID_10C4&amp;PID_EA60\\0001 Silicon Labs 进入终端 123456PS C:\\&gt;serialport-term.cmd -p COM3 -b 115200l▒\"rdr$r▒n▒▒▒▒▒oܟ▒▒#r▒▒b쏜#$▒#$▒▒l#$▒▒ln▒p&#123;l▒l▒▒|▒▒▒#4 ets_task(40100164, 3, 3fff837c, 4)OSError: [Errno 2] ENOENTMicroPython v1.9.2-8-gbf8f45cf on 2017-08-23; ESP module with ESP8266Type \"help()\" for more information. 使用 MicroPython 进行编程// TODO 串口编程使用 node-serialport 使用process.stdin.setRawMod(true)获取所有按键输入，包括控制按键等,实现串口连接的模拟终端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const PORT_NAME = 'COM3'const BAUD_RATE = 115200 // config thoseconst colors = require('colors')const SerialPort = require('serialport');const port = new SerialPort(PORT_NAME, &#123; baudRate: 115200, autoOpen: false, rtscts: true&#125;);const itOut = (data) =&gt; &#123; process.stdout.write(data.toString())&#125;const itError = (data) =&gt; &#123; process.stdout.write(data.toString())&#125;port.open(e =&gt; &#123; port.write('import os;os.listdir()\\r') // '\\r' is return means next line, in Windows is '\\r\\n' port.on('error', err =&gt; &#123; itError(err) &#125;) port.on('end', (s) =&gt; &#123; port.flush() port.close(); &#125;) port.on('readable', function () &#123; itOut(port.read()) &#125;); process.stdin.setRawMode(true) let exitCounter = 0 process.stdin.on('data', (s) =&gt; &#123; if (s[0] === 0x03) &#123; if (exitCounter == 1) &#123; itOut('bye\\n') port.close(); process.exit(0); &#125; else &#123; itOut('Wanna exit? ctrl+c continue.\\n') port.write(s) // ctrl+c 终止当前运行的程序 exitCounter++; &#125; &#125; else &#123; exitCounter = 0 port.write(s) &#125; if (s[0] === 0x0d) &#123; itOut('\\n') &#125; &#125;);&#125;) non-blocking input | raw input类似 node.js process.stdin.setRawMode(true) 的操作，不需要回车，获取所有包括ctrl+B等不可见字符 Python1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 参考 Django createsuperuser 的时候输入密码的功能import platformfrom sys import stdoutclass Getcher: def __init__(self): self.__getch = None if platform.system() == 'Windows': import msvcrt def getch_func(): return int.from_bytes(msvcrt.getch(), byteorder='little') self.__getch = getch_func else: def getch_func_cursor(): import curses window = curses.initscr() curses.noecho() window.keypad(True) def getch_func(): try: stdout.write('\\r') # return line first position key = window.getch() return key except KeyboardInterrupt: curses.endwin() return 3 except Exception: curses.endwin() return getch_func self.__getch = getch_func_cursor() def getch(self): return self.__getch()g = Getcher()while True: k = g.getch() if k == 3: exit(0) print(chr(k))","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zh-h.github.io/categories/Linux/"}],"tags":[{"name":"python","slug":"python","permalink":"https://zh-h.github.io/tags/python/"},{"name":"IoT","slug":"IoT","permalink":"https://zh-h.github.io/tags/IoT/"}]},{"title":"Spring Boot 内嵌 tomcat 调优","slug":"2017/10/14/spring-boot-embedded-tomcat-tunning","date":"2017-10-13T16:00:00.000Z","updated":"2019-10-26T21:49:24.152Z","comments":true,"path":"2017/10/14/2017/10/14/spring-boot-embedded-tomcat-tunning/","link":"","permalink":"https://zh-h.github.io/2017/10/14/2017/10/14/spring-boot-embedded-tomcat-tunning/","excerpt":"","text":"前言为了能够承受更多的用户量，并且改善性能，需要对 Sevlet 容器的最大连接数、最大线程数、IO模式进行设置。 外部 Tomcat 参数调优略。 Spring Boot 内嵌 tomcat 参数调优面试被问到达这个问题，一般都是使用默认参数，还没有实际调整的经验，于是回答了 JVM 的命令行参数。。。 Spring Boot 配置属性以下是默认的 Tomcat 容器在 Spring Boot 中的配置属性 application.properties 1234567891011121314151617181920212223242526272829303132server.tomcat.accesslog.directory=logs # Directory in which log files are created. Can be relative tothe tomcat base dir or absolute.server.tomcat.accesslog.enabled=false # Enable access log.server.tomcat.accesslog.pattern=common # Format pattern for access logs.server.tomcat.accesslog.prefix=access_log # Log file name prefix.server.tomcat.accesslog.rename-on-rotate=false # Defer inclusion of the date stamp in the file nameuntil rotate time.server.tomcat.accesslog.request-attributes-enabled=false # Set request attributes for IP address,Hostname, protocol and port used for the request.server.tomcat.accesslog.suffix=.log # Log file name suffix.server.tomcat.background-processor-delay=30 # Delay in seconds between the invocation ofbackgroundProcess methods.server.tomcat.basedir= # Tomcat base directory. If not specified a temporary directory will be used.server.tomcat.internal-proxies=10\\\\.\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125;|\\\\192\\\\.168\\\\.\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125;|\\\\169\\\\.254\\\\.\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125;|\\\\127\\\\.\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125;|\\\\172\\\\.1[6-9]&#123;1&#125;\\\\.\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125;|\\\\172\\\\.2[0-9]&#123;1&#125;\\\\.\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125;|\\\\172\\\\.3[0-1]&#123;1&#125;\\\\.\\\\d&#123;1,3&#125;\\\\.\\\\d&#123;1,3&#125; # regular expression matching trusted IP addresses.server.tomcat.max-threads=0 # Maximum amount of worker threads. 最大线程数server.tomcat.min-spare-threads=0 # Minimum amount of worker threads. 最小线程数server.tomcat.port-header=X-Forwarded-Port # Name of the HTTP header used to override the original portvalue.server.tomcat.protocol-header= # Header that holds the incoming protocol, usually named &quot;X-ForwardedProto&quot;.server.tomcat.protocol-header-https-value=https # Value of the protocol header that indicates that theincoming request uses SSL.server.tomcat.redirect-context-root= # Whether requests to the context root should be redirected byappending a / to the path.server.tomcat.remote-ip-header= # Name of the http header from which the remote ip is extracted. Forinstance `X-FORWARDED-FOR`server.tomcat.uri-encoding=UTF-8 # Character encoding to use to decode the URI. 我们能从中进行调整的主要是max-threads和min-spare-threads两个参数。 TomcatEmbeddedServletContainerFactory但是我们需要设置 Tomcat 的最大连接数呢？不像独立的 Tomcat 可以配置server.xml文件，Spring Boot 内置的 Tomcat 支持使用 Java 编码进行配置，可以重写TomcatEmbeddedServletContainerFactory 1234567891011121314151617181920212223242526package me.zonghua.tomcat.tunning;import org.apache.catalina.connector.Connector;import org.apache.coyote.http11.Http11NioProtocol;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.context.embedded.tomcat.TomcatEmbeddedServletContainerFactory;import org.springframework.stereotype.Component;@Componentpublic class CustomEmbeddedServletContainerFactory extends TomcatEmbeddedServletContainerFactory &#123; private static final Logger LOGGER = LoggerFactory.getLogger(CustomEmbeddedServletContainerFactory.class.getName()); @Value(\"$&#123;server.tomcat.max-connections&#125;\") private Integer maxConnections = 1024; @Override protected void customizeConnector(Connector connector) &#123; super.customizeConnector(connector); super.customizeConnector(connector); Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler(); protocol.setMaxConnections(maxConnections); //设置最大连接数,请他参数请参考 protocol 的属性 LOGGER.info(\"Embedded tomcat max connections set: \" + maxConnections); &#125;&#125; 以下是可以支持更改的属性： maxConnections: 这个值表示最多可以有多少个socket连接到tomcat上。NIO模式下默认是10000. maxThreads： Tomcat使用线程来处理接收的每个请求。这个值表示Tomcat可创建的最大的线程数。默认值150。 acceptCount： 指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理。默认值10。 minSpareThreads： Tomcat初始化时创建的线程数。默认值25。 maxSpareThreads： 一旦创建的线程超过这个值，Tomcat就会关闭不再需要的socket线程。默认值75。 enableLookups： 是否反查域名，默认值为true。为了提高处理能力，应设置为false connnectionTimeout： 网络连接超时，默认值60000，单位：毫秒。设置为0表示永不超时，这样设置有隐患的。通常可设置为30000毫秒。 maxKeepAliveRequests： 保持请求数量，默认值100。 bufferSize： 输入流缓冲大小，默认值2048 bytes。 compression： 压缩传输，取值on/off/force，默认值off。 其中和最大连接数相关的参数为maxThreads和acceptCount。如果要加大并发连接数，应同时加大这两个参数。 JVM 参数可以使用 Maven 插件指定打包后 jar 运行的默认 JVM 参数。 pom.xml 123456789101112&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;executable&gt;true&lt;/executable&gt; &lt;jvmArguments&gt;-Xms512m -Xmx512m -XX:NewSize=64m -XX:MaxNewSize=512m -XX:PermSize=256m&lt;/jvmArguments&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; JVM 调优是一门玄学，如果掌握后那就是高级工程师了。。。 https://www.cubrid.org/blog/how-to-tune-java-garbage-collection tomcat tunning","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://zh-h.github.io/tags/Spring/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://zh-h.github.io/tags/Tomcat/"}]},{"title":"Java 8 的一些使用技巧","slug":"2017/10/4/using-java8","date":"2017-10-03T16:00:00.000Z","updated":"2019-10-26T21:49:24.153Z","comments":true,"path":"2017/10/04/2017/10/4/using-java8/","link":"","permalink":"https://zh-h.github.io/2017/10/04/2017/10/4/using-java8/","excerpt":"","text":"Java 8 发布三年后，今年年底将要发布 Java 9。然而对于很多使用者来说，受限与旧项目的稳定性考虑以及框架封装隐藏底层 API，很多 Java 8 的特性都没有使用上。 刚刚受封为 Android 官方语言的 Kotlin 似乎热潮已经冷却，虽然 Kotlin 有着甜蜜蜜的语法糖，但是表面易用的语法实际上却埋下了很多坑（解毒 Kotlin Koans: 02 震惊！你的 Java 代码居然被转换成了这样…），上线使用还要做很多深入学习。 为了迎接 Java 9，还是先把 Java 8 用熟。。。 文件操作以往为了读取一个文本文件的内容可能需要需要十几行代码。 123456789101112131415161718192021public static String readTranslateJsonFileToString(String resourceName) &#123; ClassLoader classLoader = LocationTranslateUtil.class.getClassLoader(); URL resource = classLoader.getResource(resourceName); StringBuilder content = new StringBuilder(); if (resource != null) &#123; File file = new File(resource.getFile()); InputStream is; try &#123; is = new FileInputStream(file); InputStreamReader isr = new InputStreamReader(is, \"UTF-8\"); BufferedReader br = new BufferedReader(isr); String temp; while ((temp = br.readLine()) != null) &#123; content.append(temp); &#125; &#125; catch (IOException e) &#123; // TODO &#125; &#125; return content.toString();&#125; 使用 java.nio.* 缩短为四行，读取类路径中的文件。1234567public String readPropertiesStr() throws IOException, URISyntaxException&#123; ClassLoader classLoader = this.getClass().getClassLoader(); URL resource = classLoader.getResource(\"config.properties\"); Path path = Paths.get(resource.toURI()); byte[] data = Files.readAllBytes(path); return new String(data, StandardCharsets.UTF_8);&#125; 时间日期时间格式化12345678910DateTimeFormatter df = DateTimeFormatter.ISO_LOCAL_DATE_TIME; // 线程安全public String getDateTimeString() &#123; LocalDateTime now = LocalDateTime.now(); return df.format(now);&#125;public LocalDateTime parseToLocalDateTime()&#123; return LocalDateTime.parse(\"2017-08-14T12:49:44.133\", df);&#125; 新增的 DateTimeFormatter 是不可变，而且是线程安全的类，因此可以直接使用在成员变量中。 明天，去年1234567public LocalDateTime nextDate()&#123; return LocalDateTime.now().plusDays(1);&#125;public LocalDateTime previousYear()&#123; return LocalDateTime.now().minusYears(1);&#125; 时间差快速计算两个本地时间的时间差，包括NANOS, MICROS, MILLIS, SECONDS, MINUTES, HOURS, HALF_DAYS, DAYS, WEEKS, MONTHS, YEARS, DECADES, CENTURIES, MILLENNIA, ERAS 时间单位 123456public long differDates() &#123; for(ChronoUnit unit : ChronoUnit.values())&#123; System.out.println(unit.name()); &#125; return ChronoUnit.DAYS.between(previousYear(),LocalDateTime.now());&#125; 早晚比较两个日期/时间的早晚，可以使用isAfter或者isBefore 方法1234LocalDate tomorrow = LocalDate.of(2017, 8, 15);if(tommorow.isAfter(LocalDate.now()))&#123; System.out.println(&quot;Tomorrow comes after today&quot;);&#125; 时区123public LocalDateTime utcNow()&#123; return LocalDateTime.now(ZoneId.of(&quot;Europe/Berlin&quot;));&#125; 转换1234public Date toOldStyleDate()&#123; Instant instance = LocalDateTime.now().atZone(ZoneId.of(&quot;Asia/Shanghai&quot;)).toInstant(); return Date.from(instance);&#125; 默认方法的接口Java 8 允许我们使用default关键字，为接口声明添加非抽象的方法实现。这个特性又被称为扩展方法。 defaut关键字接口也可以有多个方法实现，使用defaut关键字修饰。 1234567891011121314151617181920interface USB &#123; String ping(); default int getPinNum() &#123; return 4; &#125;&#125;public class DefaultMethodInInterface &#123; public static void main(String[] args) &#123; USB usb2_0 = new USB() &#123; @Override public String ping() &#123; return \"OK\"; &#125; &#125;; System.out.println(usb2_0.getPinNum()); &#125;&#125; Java 多继承既然接口都可以包含多个方法实现，那么Java本身可以实现多个接口，这样是不是可以实现多继承？ 可以实现Java的多继承。 12345678910111213141516171819202122232425262728interface USB &#123; String ping(); default int getPinNum() &#123; return 4; &#125;&#125;interface Plugin &#123; default String plug() &#123; return \"biu\"; &#125;&#125;class USB3_0 implements USB, Plugin &#123; @Override public String ping() &#123; return \"OK\"; &#125;&#125;public class DefaultMethodInInterface &#123; public static void main(String[] args) &#123; USB3_0 usb3_0 = new USB3_0(); System.out.println(usb3_0.getPinNum()); System.out.println(usb3_0.plug()); &#125;&#125; Lambda省略匿名类实现单个方法的接口，直接使用单行表达式或者块。 1234567891011List&lt;String&gt; names = Arrays.asList(\"hua\", \"zohar\", \"zonghua\");Collections.sort(names, new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; // 前者比后者小 System.out.println(o1 + \" --- \" + o2); return (int) o1.toCharArray()[0] - (int) o2.toCharArray()[0]; &#125;&#125;);// 方法引用 String::compareToCollections.sort(names, (o1, o2) -&gt; o1.compareTo(o2)); 函数式接口@FunctionalInterface 注解使用该注解声明一个接口只包含一个抽象方法，但是可以包含多个默认方法实现。 123456789101112@FunctionalInterfaceinterface SomeThing&#123; String say();&#125;public class TheFunctionalInterface &#123; public static void main(String[] args) &#123; SomeThing someThing = () -&gt; \"lala\"; System.out.println(someThing.say()); &#125;&#125; 方法引用可以从类或者实例中获取方法引用，使用::符号 1234567891011121314151617181920class SomeClass &#123; String say() &#123; return \"haha\"; &#125;&#125;class OtherClass &#123; static String say()&#123; return \"66666\"; &#125;&#125;public class TheMethodReference &#123; public static void main(String[] args) &#123; SomeClass someObject = new SomeClass(); SomeThing someThing = someObject::say; SomeThing otherThing = OtherClass::say; System.out.println(someThing.say()); System.out.println(otherThing.say()); &#125;&#125; 作用域与匿名类的访问类似，实际上访问外部变量只能是final修饰变量，虽然可以省略，但再次变更变量会导致编译出错。 123456789101112131415161718@FunctionalInterfaceinterface Lala &#123; String say();&#125;public class TheLambdaContext &#123; public static void main(String[] args) &#123; String[] name = new String[]&#123;\"Lily\"&#125;; Lala lala = () -&gt; name[0] + \" hehe\"; System.out.println(lala.say());// name = new String[]&#123;\"What\"&#125;; 不可变更引用或者值 lala = () -&gt; &#123; name[0] = \"Zoar\"; return name[0]; &#125;; System.out.println(lala.say()); &#125;&#125; 内嵌函数式接口Functions接收一个传入参数，返回结果，使用默认的方法。 12345678910111213Function&lt;String, Integer&gt; lala = (str) -&gt; 1; // &lt;input,return&gt;System.out.println(lala.apply(\"lala\").addThen(Objects::notNull));Supplier&lt;String&gt; hehe = () -&gt; \"lala\"; // 没有输入参数System.out.println(hehe.get());Consumer&lt;String&gt; whatsUp = (str) -&gt; str = str.substring(0, 1);String someThing = \"lala\";whatsUp.accept(someThing);System.out.println(someThing);Comparator&lt;String&gt; strCompare = (o1, o2) -&gt; o1.compareTo(o2); // 前者比后者大为正System.out.println(strCompare.compare(\"a\", \"b\")); Predicates传入参数，返回布尔值。具有逻辑方法or and negate。 12345678910Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;predicate.test(\"foo\"); // truepredicate.negate().test(\"foo\"); // falsePredicate&lt;Boolean&gt; nonNull = Objects::nonNull;Predicate&lt;Boolean&gt; isNull = Objects::isNull;Predicate&lt;String&gt; isEmpty = String::isEmpty;Predicate&lt;String&gt; isNotEmpty = isEmpty.negate(); Suppliers没有传入参数，返回给定类型。 12Supplier&lt;String&gt; hehe = () -&gt; \"lala\"; // 没有输入参数System.out.println(hehe.get()); Consumers没有返回参数，给定输入类型。 1234Consumer&lt;String&gt; whatsUp = (str) -&gt; str = str.substring(0, 1);String someThing = \"lala\";whatsUp.accept(someThing);System.out.println(someThing); Comparators对比两个传入参数，左边的比右边的大就返回正值，反则负值，相等为0。 12Comparator&lt;String&gt; strCompare = (o1, o2) -&gt; o1.compareTo(o2); // 前者比后者大为正System.out.println(strCompare.compare(\"a\", \"b\")); Optionals一个存储结果的容器，用来省掉函数过程中的if xx != null。 1234567Optional&lt;String&gt; optional = Optional.of(\"lala\");optional.isPresent(); // trueoptional.get(); // \"lala\"optional.orElse(\"hehe\"); // \"lala\"optional.ifPresent((s) -&gt; System.out.println(s.charAt(0))); // \"l\" 流处理Filter过滤掉集合中的某些元素，传入参数是元素，返回过滤判断的布尔值。 12345names.stream() .filter(Objects::nonNull) .map(String::toUpperCase) .sorted(((o1, o2) -&gt; -o1.compareTo(o2))) .forEach(System.out::println); Sorted传入前后两个参数，返回两者判断的有符号整数。 12345names.stream() .filter(Objects::nonNull) .map(String::toUpperCase) .sorted(((o1, o2) -&gt; -o1.compareTo(o2))) .forEach(System.out::println); 原来集合的顺序并不会被改变 Map传入一个元素，处理后返回这个元素。 12345names.stream() .filter(Objects::nonNull) .map(String::toUpperCase) .sorted(((o1, o2) -&gt; -o1.compareTo(o2))) .forEach(System.out::println); anyMatch在集合中查找匹配的元素。 123boolean hasStartWith0 = names.stream() .anyMatch((s) -&gt; s.startsWith(\"0\")); System.out.println(hasStartWith0); Reduce传入最终元素、每个元素，把每个元素处理到最终的元素中。 1234567Optional&lt;String&gt; namesStr = names.stream() .filter(TheStreams::nonNull) .reduce((o1, o2) -&gt; &#123; System.out.println(o2); return o1 + \" - \" + o2; &#125;); // 最终元素,每个元素namesStr.ifPresent(System.out::println); Count计算集合中的数量 12345long count = names.stream() .filter(TheStreams::nonNull) .filter((s) -&gt; s.startsWith(\"0\") || s.startsWith(\"L\")) .count();System.out.println(count); 并行化Java 8 流操作内部封装了多线程调用，可以使用流操作进行并行处理。 123456789101112131415161718192021public static List&lt;String&gt; generateRandomNameList() &#123; int max = 1000000; List&lt;String&gt; values = new ArrayList&lt;&gt;(max); for (int i = 0; i &lt; max; i++) &#123; UUID uuid = UUID.randomUUID(); values.add(uuid.toString()); &#125; return values;&#125;public static long sequenceSort(List&lt;String&gt; names) &#123; return names.stream() .sorted() .count(); // 3s518ms&#125;public static long parallelSort(List&lt;String&gt; names) &#123; return names.parallelStream() .sorted() .count(); //2s134ms&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/tags/Java/"}]},{"title":"Spring Boot 注册为 Linux 系统服务","slug":"2017/09/25/spring-boot-linux-service","date":"2017-09-24T16:00:00.000Z","updated":"2019-10-26T21:49:24.152Z","comments":true,"path":"2017/09/25/2017/09/25/spring-boot-linux-service/","link":"","permalink":"https://zh-h.github.io/2017/09/25/2017/09/25/spring-boot-linux-service/","excerpt":"","text":"服务管理Spring Boot 不需要依赖外部 Servlet 容器，可以直接通过java -jar app.jar的方式执行。 在一些情况下不适用 Docker 容器管理 Spring Boot 进程的时候，需要使用其他的进程管理工具管理，如systemctl需要编写管理脚本。 实际上 Maven 插件打包 Spring Boot 的时候可以直接生成管理脚本，然后直接使用服务管理。 插件配置Maven 配置1234567&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;executable&gt;true&lt;/executable&gt; &lt;/configuration&gt;&lt;/plugin&gt; Gradle 配置 12345apply plugin: 'org.springframework.boot'springBoot &#123; executable = true&#125; 建立软链接经过打包的可执行脚本被内置在Spring Boot jar包里，链接到/etc/init.d。 可以将应用安装在/var/myapp, 使用下面命令将Spring Boot应用作为init.d服务。 12chmod a+x /var/myapp/myapp.jarln -s /var/myapp/myapp.jar /etc/init.d/myapp 管理进程注册到到服务后管理进程将十分方便。 1/etc/init.d/myapp [start|stop|restart] 进程的PID在/var/run/myapp/myapp.pid 日志被重定向到/var/log/myapp.log","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zh-h.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zh-h.github.io/tags/Linux/"},{"name":"Spring","slug":"Spring","permalink":"https://zh-h.github.io/tags/Spring/"}]},{"title":"iPhone Fiddler HTTPS 抓包","slug":"2017/09/19/ios-fiddler-intercept","date":"2017-09-18T16:00:00.000Z","updated":"2019-10-26T21:49:24.152Z","comments":true,"path":"2017/09/19/2017/09/19/ios-fiddler-intercept/","link":"","permalink":"https://zh-h.github.io/2017/09/19/2017/09/19/ios-fiddler-intercept/","excerpt":"","text":"前期准备 iOS设备和电脑保证在一个网段内，相互间可联通。 下载安装 Fiddler 配置启动 Fiddler 以下截图为 Windows 平台，其他平台 Fiddler 可做参考。 解码 HTTPS打开 Tool &gt; Options &gt; HTTPS 设置 Fiddler 解码 HTTPS 内容 http://wx2.sinaimg.cn/large/e7c91439gy1fjp3iuk3whj20f50a9gm1.jpg 开启远程访问打开 Tool &gt; Options &gt; Connections 勾选 Allow remote computers to connect 重启 Fiddler重启 Fiddler 代理服务器才会生效 添加代理设置查看电脑的内网IP 打开 iOS 设备的无线局域网 &gt; 代理设置 填写IP和默认的端口 8888 http://wx3.sinaimg.cn/large/e7c91439gy1fjp3ivnp9gj20jz0zk40t.jpg 打开 http://ip:8888 点击 Fiddler certificate 安装认证证书 http://wx4.sinaimg.cn/large/e7c91439gy1fjp3iuil1ej20jz0zkgmg.jpg 打开 iOS 设备的通用 &gt; 关于本机 使证书可信 http://wx3.sinaimg.cn/large/e7c91439gy1fjp3iuigvrj20jz0zkgmg.jpg 示例-访问微信公众号文章阅读数 打开微信应用，点击访问任意文章 http://wx3.sinaimg.cn/large/e7c91439gy1fjp447j65bj20jz0zk0uq.jpg 检查 Fiddler 左侧回话列表 点击带 getappmsgext 的 url 右侧面板上面是 HTTP 头部内容 右侧面板下部是 HTTP 正文 点击 TextView 选项卡 点击上面提示的 Response body is encoded, click to decode 提示 查看解码后的正文内容 http://wx4.sinaimg.cn/large/e7c91439gy1fjp3iv3pkxj20im0bt752.jpg 流程 123456789101112+-------+ +------------------+ +------+| | | | | || | request | intercept | request | || | +-----&gt; | | +----&gt; | || | | dencrypt | | || | response | | response | || | &lt;----+ | decode | &lt;-----+ | || | | | | || | | parse | | || | | | | |+-------+ +------------------+ +------+ iPhone Fidder Website","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zh-h.github.io/categories/Linux/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://zh-h.github.io/tags/计算机网络/"}]},{"title":"负载均衡原理","slug":"2017/08/21/load-brance","date":"2017-08-20T16:00:00.000Z","updated":"2019-10-26T21:49:24.152Z","comments":true,"path":"2017/08/21/2017/08/21/load-brance/","link":"","permalink":"https://zh-h.github.io/2017/08/21/2017/08/21/load-brance/","excerpt":"","text":"说明负载均衡对物理、虚拟服务器或者独立应用进行网络流量的分发，可以包括传输层和应用程的处理。 负载均衡可以通过流量分发扩展应用系统对外的服务能力，通过消除单点故障提升应用系统的可用性。 负载均衡策略 Round Robin 对所有可用后端进行循环访问。 Least Connections(least_conn) 跟踪记录后端的连接数，优先选择链接数少的服务，将请求转发，并且设计每个upstream分配的weight权重信息。 Least Time(least_time) 请求会分配给响应最快和活跃连接数最少的后端。 IP Hash(ip_hash) 对请求来源IP地址计算hash值，然后根据得到的hash值通过某种映射分配到后端（Nginx常用）。 Generic Hash(hash) 以用户自定义资源(比如URL)的方式计算hash值完成分配，其可选consistent关键字支持一致性hash特性； 常见负载均衡实现Nginx使用 Nginx 进行负载均有以下特点： 运行在应用层，对HTTP应用进行分流。 常用IP hash进行回话绑定。 反向代理可以实现缓存。 缺点： 支持的应用协议少，只支持HTTP、HTTPS和WebSocket等。 支持应用端口的可用性检查。 Haproxy优点： 运行于四层网络，可以进行TCP协议的负载均衡，如数据库的°负载均衡。 比其他负载均衡软件高的性能。 DNS通常应用在多地多级房，多运营商网络的负载均衡。 健康检查keepalived// TODO","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"}],"tags":[{"name":"架构","slug":"架构","permalink":"https://zh-h.github.io/tags/架构/"}]},{"title":"并发编程词义","slug":"2017/08/18/concurrency-programming-01","date":"2017-08-17T16:00:00.000Z","updated":"2019-10-26T21:49:24.152Z","comments":true,"path":"2017/08/18/2017/08/18/concurrency-programming-01/","link":"","permalink":"https://zh-h.github.io/2017/08/18/2017/08/18/concurrency-programming-01/","excerpt":"","text":"并发 (concurrency) 与并行 (parallelism)并发两个或多个事件在同一时间间隔发生，微观上串行； 并行两个或者多个事件在同一时刻发生，充分利用多核处理器。 原子性 (atomicity) (CAS) 原子性不论是多核还是单核，具有原子性的量，同一时刻只能有一个线程来对它进行操作； i++ 运算不具有原子性。 可见性 (visibility)多个线程对一个共享变量进行操作时，由于编译器或者硬件优化的缘故，a 线程修改了变量的值，但是 b 线程缓存了变量原来的值，读取的就是 cache 中或者寄存器里的数据。(volatile) 进程、线程和协程进程“程序执行的一个实例” ，担当分配系统资源的实体。进程创建必须分配一个完整的独立地址空间； 线程线程创建的开销主要取决于为线程堆栈的建立而分配内存的开销，这些开销并不大。线程上下文切换发生在两个线程需要同步的时候，比如进入共享数据段，由操作系统进行调度； 协程与线程一样共享堆，不共享栈，协程调度切换时，将寄存器上下纹和栈保存起来，协程由程序定义调度(goto)。","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zh-h.github.io/tags/Linux/"},{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/tags/Java/"}]},{"title":"Nginx 启用 Base Auth 实现用户认证","slug":"2017/08/13/nginx-base-auth","date":"2017-08-12T16:00:00.000Z","updated":"2019-10-26T21:49:24.152Z","comments":true,"path":"2017/08/13/2017/08/13/nginx-base-auth/","link":"","permalink":"https://zh-h.github.io/2017/08/13/2017/08/13/nginx-base-auth/","excerpt":"","text":"如果一些 Web 系统（如：Kibana）没有提供用户认证管功能，可以使用 Nginx 反向代理启用 Base Auth。 Base Auth安全性低，不检验在外网直接使用，请务必添加SSL 安装 httpd-tools1apt-get install apache2-utils 生成用户密码1htpasswd -c /etc/nginx/.htpasswd admin 修改 Nginx 配置针对 Nginx 配置不同的上下文，可以针对服务器或者目录进行验证： nginx.conf 1234location / &#123; auth_basic &quot;HTTP Basic Authentication&quot;; auth_basic_user_file /etc/nginx/.htpasswd; &#125; 重载 Nginx1service nginx reload 在 Dockerfile 中配置本示例基础镜像以 Ubuntu 或者 Debian 为基准，编辑 Dockerfile 12345ENV BASE_AUTH=admin:adminadminRUN apt-get install apache2-utils -y &amp;&amp; \\ mkdir -p /etc/nginx &amp;&amp; \\ echo $BASE_AUTH &gt; /etc/nginx/.htpasswd docker-nginx.conf 1234567891011auth_basic &quot;HTTP Basic Authentication&quot;; auth_basic_user_file /etc/nginx/.htpasswd; location ~ \\.php$ &#123; try_files $uri /index.php =404; fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_pass php-fpm:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /var/www/html/$fastcgi_script_name; include /etc/nginx/fastcgi_params;&#125;","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zh-h.github.io/categories/Linux/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://zh-h.github.io/tags/Nginx/"}]},{"title":"Kotlin Servlet 示例","slug":"2017/08/11/kotlin-servlet","date":"2017-08-10T16:00:00.000Z","updated":"2019-10-26T21:49:24.152Z","comments":true,"path":"2017/08/11/2017/08/11/kotlin-servlet/","link":"","permalink":"https://zh-h.github.io/2017/08/11/2017/08/11/kotlin-servlet/","excerpt":"","text":"添加 Servlet 依赖添加 JaveEE 的API，包含了 Servlet 的引用。 12345dependencies &#123; compile group: 'javax', name: 'javaee-api', version: '7.0' compile \"org.jetbrains.kotlin:kotlin-stdlib-jre8:$kotlin_version\" testCompile group: 'junit', name: 'junit', version: '4.12'&#125; Gradle Tomcat Plugin使用 jetty plugin 无法加载注解的 servlet，请使用 tomcat plugin 编辑gradle.build,附加 tomcat 插件，配置启动任务。 123456789101112131415161718192021apply plugin: \"war\"apply plugin: 'com.bmuschko.tomcat'buildscript &#123; dependencies &#123; classpath 'com.bmuschko:gradle-tomcat-plugin:2.3' &#125;&#125;dependencies &#123; def tomcatVersion = '8.5.16' tomcat \"org.apache.tomcat.embed:tomcat-embed-core:$&#123;tomcatVersion&#125;\", \"org.apache.tomcat.embed:tomcat-embed-logging-juli:8.5.2\", \"org.apache.tomcat.embed:tomcat-embed-jasper:$&#123;tomcatVersion&#125;\"&#125;tomcat &#123; httpProtocol = 'org.apache.coyote.http11.Http11Nio2Protocol' ajpProtocol = 'org.apache.coyote.ajp.AjpNio2Protocol' contextPath = ''&#125; 创建src/main/webapp目录，添加index.html文件，编辑内容。 12345678&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello Kotlin&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello Kotlin&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 添加控制器添加me.zohar.kotlin.servlet.HelloController，这个控制器继承了HttpServlet,并且调用默认的父类的构造方法。 12345678910111213package me.zohar.kotlin.servlet.controllerimport javax.servlet.annotation.WebServletimport javax.servlet.http.HttpServletimport javax.servlet.http.HttpServletRequestimport javax.servlet.http.HttpServletResponse@WebServlet(name = \"Hello\", value = \"/\")class HomeController : HttpServlet() &#123; override fun doGet(req: HttpServletRequest, res: HttpServletResponse) &#123; res.writer.write(\"Hello, World!\") &#125;&#125; 访问http://localhost:8080/","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://zh-h.github.io/categories/Kotlin/"}],"tags":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://zh-h.github.io/tags/Kotlin/"},{"name":"Servlet","slug":"Servlet","permalink":"https://zh-h.github.io/tags/Servlet/"}]},{"title":"PHP大型网站的架构总结","slug":"2017/08/10/large-PHP-website-architecture","date":"2017-08-09T16:00:00.000Z","updated":"2019-10-26T21:49:24.151Z","comments":true,"path":"2017/08/10/2017/08/10/large-PHP-website-architecture/","link":"","permalink":"https://zh-h.github.io/2017/08/10/2017/08/10/large-PHP-website-architecture/","excerpt":"","text":"本文对工作中接触到的部分架构进行归纳总结。 一个大型的Web系统，要面对上亿的注册用户，大量的用户内容，巨大的访问量还有EB级别的数据存储。 操作系统所有软件都要运行在操作系统上，因此操作系统要保证高效、稳定和安全。包管理工具提供丰富的、稳定、新的软件包也是重要的选择。 Ubuntu新潮，有很多软件包可以快速跟进； 简单，易用。 CentOSCentOS的生命周期是7年，基本上可以覆盖硬件的生命周期； 对硬件的支持更好（有些服务器是自行组装的机器）； PXE 安装系统比 Ubuntu 快多了； 稳定。 Windows Server主要用途是特定平台的 Microso Office 文档转换服务。 虚拟化OpenStack运行环境本文接触到的体系主要使用的是动态语言，在运行环境/解释器中运行，需要保证运行的高效与稳定啊。 PHPWeb 服务器不能直接执行 PHP ， 当接收到请求后，会把请求交给 PHP 解释器处理，处理结果返回给客户端。 请求转发过程需要用到 CGI 管理器，使用 Nginx + PHP-FPM。 PHP-FPM 维护一个进程池，进程复用中处理多个请求，相比 Apache PHP-Mod 一个请求一个进程大大提高了处理速度、降低了内存消耗。 Node.js主要用在消息推送系统中，相比 PHP 有以下显著优点： 采用事件驱动、异步编程，为网络服务而设计。其实Javascript的匿名函数和闭包特性非常适合事件驱动、异步编程； Node.js非阻塞模式的IO处理模式非常适合大量链接的客户端进行大量的数据推送（使用 Websocket 兼容 Web 端）。 Node.js 的缺点也是显著的： 可靠性低，回调出错难以排查，一个线程奔溃就需要重启整个进程； 单进程，单线程，只支持单核CPU。当前的集群方案也不能很好利用机器资源，还造成监控维护困难。 Web 服务器处理静态文件的访问，并且提供反向代理到内网的 Http 或者 Websocket 服务。需要运行集群，保证可用度。 Nginx一款轻量级、高性能的 Web 服务器/反向代理服务器，配合 PHP-FPM 能够得到更高的运行效率。 文件系统FastDFS开源的分布式文件系统，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。 SQLMariaDBMariaDB数据库管理系统是 MySQL 的一个分支，主要由开源社区在维护，采用GPL授权许可 MariaDB的目的是完全兼容MySQL。 使用 MariaDB 而不使用 MySQL 的原因是为了规避 Oracle 收购 MySQL 后协议变更导致的使用授权风险。 MyCat单表、单库无法应对大量数据，所以需要进行数据库的拆分，数据库集群使用 MyCat 进行分表、分库、联合查询处理。 NoSQLElasticsearch分布式的文档检索服务，可以提供文章页面的检索服务。 由于 Elasticsearch 提供了 JSON 的数据查询和存储模式，能够实现很多 NoSQL 的特性，因此也会在 Elasticsearch 直接存储标签等数据。相比关系数据库可以提供更快的查询速度。 各个模块的系统使用 Logstash 过滤日志存储到 Elasticsearch 中，使用 Kibana 进行查看，就是 ELK 日志处理方案。 CouchDB使用 CouchDB 进行 Web 集群的 Session 共享。 Redis提供了丰富的数据结构，可以在应用中执行各种缓存，分布式提供大量数据、高可用的服务。 负载均衡HaProxy提供高可用性、负载均衡以及基于TCP（第四层）和HTTP（第七层）应用的代理。 Redis 使用 HAProxy 实现分布式集群。 消息中间件Rabbit MQ 耗时任务（视频转码，文档转换）需要发送到消息队列中，然后由大量的 Worker 进行处理，处理结果返回到消息队列中，或者持久化到数据库。 缓冲大量并发的访问，进行流量削峰。 RPCThrift高效、多语言的远程执行框架。 YarPHP 使用的并行化远程执行框架。 应用框架Gearman把任务分发到不同的进程中处理，对工作进行并行化和负载均衡处理。 运维监控Puppet自动化配置和管理工具，可以通过集群对大量的服务器进行管理。 自动化运维系统中通过 Puppet 推送执行脚本到指定的服务器群组。 Cacti网络流量监控，rrdtool 生成图标。 Nagios 监控系统、应用和交换机网络设备； 自定义监控规则； 插件提供邮件、短信、微信乃至电话的告警通知。","categories":[{"name":"PHP","slug":"PHP","permalink":"https://zh-h.github.io/categories/PHP/"}],"tags":[]},{"title":"// TODO 把 Gitlab 上的 Wiki 迁移过来","slug":"import-gitlab","date":"2017-08-08T13:21:00.000Z","updated":"2019-10-26T21:49:24.160Z","comments":true,"path":"2017/08/08/import-gitlab/","link":"","permalink":"https://zh-h.github.io/2017/08/08/import-gitlab/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-08-08T13:15:00.000Z","updated":"2019-10-26T21:49:24.160Z","comments":true,"path":"2017/08/08/hello-world/","link":"","permalink":"https://zh-h.github.io/2017/08/08/hello-world/","excerpt":"","text":"import this从 Typecho 迁移到 Hexodocker-typecho 把原来所有文章生成 Hexo 规范的 Mardown。","categories":[],"tags":[]},{"title":"Dockerfile 中 CMD 和 ENTRYPONINT 的区别","slug":"2017/06/09/differrent-between-cmd-and-entrypoint","date":"2017-06-09T07:05:00.000Z","updated":"2019-10-26T21:49:24.151Z","comments":true,"path":"2017/06/09/2017/06/09/differrent-between-cmd-and-entrypoint/","link":"","permalink":"https://zh-h.github.io/2017/06/09/2017/06/09/differrent-between-cmd-and-entrypoint/","excerpt":"","text":"CMD在容器运行的时候会将这个参数作为命令运行。 Dockerfile 1CMD [&apos;date&apos;] 运行 1docker run -it image 输出 1Wed, Aug 9, 2017 3:10:37 PM 这个参数可以被覆盖 运行 1docker run -it image df 输出 12Filesystem 1K-blocks Used Available Use% Mounted onC:/Program Files/Git 116639740 42583436 74056304 37% / ENTRYPOINT功能与CMD非常类似，但是容器运行时会将参数当作参数运行，原有的命令不会被覆盖 Dockerfile 1ENTRYPOINT [&apos;date&apos;] 运行 1docker run -it image --help 输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102Usage: date [OPTION]... [+FORMAT] or: date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]Display the current time in the given FORMAT, or set the system date.Mandatory arguments to long options are mandatory for short options too. -d, --date=STRING display time described by STRING, not &apos;now&apos; --debug annotate the parsed date, and warn about questionable usage to stderr -f, --file=DATEFILE like --date; once for each line of DATEFILE -I[FMT], --iso-8601[=FMT] output date/time in ISO 8601 format. FMT=&apos;date&apos; for date only (the default), &apos;hours&apos;, &apos;minutes&apos;, &apos;seconds&apos;, or &apos;ns&apos; for date and time to the indicated precision. Example: 2006-08-14T02:34:56-06:00 -R, --rfc-2822 output date and time in RFC 2822 format. Example: Mon, 14 Aug 2006 02:34:56 -0600 --rfc-3339=FMT output date/time in RFC 3339 format. FMT=&apos;date&apos;, &apos;seconds&apos;, or &apos;ns&apos; for date and time to the indicated precision. Example: 2006-08-14 02:34:56-06:00 -r, --reference=FILE display the last modification time of FILE -s, --set=STRING set time described by STRING -u, --utc, --universal print or set Coordinated Universal Time (UTC) --help display this help and exit --version output version information and exitFORMAT controls the output. Interpreted sequences are: %% a literal % %a locale&apos;s abbreviated weekday name (e.g., Sun) %A locale&apos;s full weekday name (e.g., Sunday) %b locale&apos;s abbreviated month name (e.g., Jan) %B locale&apos;s full month name (e.g., January) %c locale&apos;s date and time (e.g., Thu Mar 3 23:05:25 2005) %C century; like %Y, except omit last two digits (e.g., 20) %d day of month (e.g., 01) %D date; same as %m/%d/%y %e day of month, space padded; same as %_d %F full date; same as %Y-%m-%d %g last two digits of year of ISO week number (see %G) %G year of ISO week number (see %V); normally useful only with %V %h same as %b %H hour (00..23) %I hour (01..12) %j day of year (001..366) %k hour, space padded ( 0..23); same as %_H %l hour, space padded ( 1..12); same as %_I %m month (01..12) %M minute (00..59) %n a newline %N nanoseconds (000000000..999999999) %p locale&apos;s equivalent of either AM or PM; blank if not known %P like %p, but lower case %q quarter of year (1..4) %r locale&apos;s 12-hour clock time (e.g., 11:11:04 PM) %R 24-hour hour and minute; same as %H:%M %s seconds since 1970-01-01 00:00:00 UTC %S second (00..60) %t a tab %T time; same as %H:%M:%S %u day of week (1..7); 1 is Monday %U week number of year, with Sunday as first day of week (00..53) %V ISO week number, with Monday as first day of week (01..53) %w day of week (0..6); 0 is Sunday %W week number of year, with Monday as first day of week (00..53) %x locale&apos;s date representation (e.g., 12/31/99) %X locale&apos;s time representation (e.g., 23:13:48) %y last two digits of year (00..99) %Y year %z +hhmm numeric time zone (e.g., -0400) %:z +hh:mm numeric time zone (e.g., -04:00) %::z +hh:mm:ss numeric time zone (e.g., -04:00:00) %:::z numeric time zone with : to necessary precision (e.g., -04, +05:30) %Z alphabetic time zone abbreviation (e.g., EDT)By default, date pads numeric fields with zeroes.The following optional flags may follow &apos;%&apos;: - (hyphen) do not pad the field _ (underscore) pad with spaces 0 (zero) pad with zeros ^ use upper case if possible # use opposite case if possibleAfter any flags comes an optional field width, as a decimal number;then an optional modifier, which is eitherE to use the locale&apos;s alternate representations if available, orO to use the locale&apos;s alternate numeric symbols if available.Examples:Convert seconds since the epoch (1970-01-01 UTC) to a date $ date --date=&apos;@2147483647&apos;Show the time on the west coast of the US (use tzselect(1) to find TZ) $ TZ=&apos;America/Los_Angeles&apos; dateShow the local time for 9AM next Friday on the west coast of the US $ date --date=&apos;TZ=&quot;America/Los_Angeles&quot; 09:00 next Fri&apos;GNU coreutils online help: &lt;http://www.gnu.org/software/coreutils/&gt;Full documentation at: &lt;http://www.gnu.org/software/coreutils/date&gt;or available locally via: info &apos;(coreutils) date invocation&apos; 优先级docker 会使用最后声明的的CMD或者ENTRYPOINT， 在引入外部的镜像的时候，可以使用自定义的声明进行覆盖。 如果两者均配置，那么CMD就相当于提供了一个默认参数。 Dockerfile 12ENTRYPOINT [&apos;df&apos;]CMD [&apos;-m&apos;] 运行 1docker run -it image 输出 12Filesystem 1M-blocks Used Available Use% Mounted onC:/Program Files/Git 113906 41589 72318 37% /","categories":[{"name":"docker","slug":"docker","permalink":"https://zh-h.github.io/categories/docker/"}],"tags":[]},{"title":"Docker 构建时移除文件中 Windows 换行符","slug":"2017/05/15/remove-windows-eof-in-dockerfile","date":"2017-05-15T07:05:00.000Z","updated":"2019-10-26T21:49:24.151Z","comments":true,"path":"2017/05/15/2017/05/15/remove-windows-eof-in-dockerfile/","link":"","permalink":"https://zh-h.github.io/2017/05/15/2017/05/15/remove-windows-eof-in-dockerfile/","excerpt":"","text":"换行符Windows 上的换行符是 \\r\\n; *nix 系统中使用 \\n。 如果在 Windows 上修改，甚至通过 Git 等版本控制工具移动文本文件，都会导致换行符的改变。 如果换行符变更，很多脚本将会运行报错，如果在 Linux 系统中使用 vi 编辑器查看，会每行后面看到 ^M 字符。 Docker 运行出错在 Windows 中使用 Docker 作为开发环境，如果启动容器的时候发现脚本执行出现错误，就要注意是否换行符导致的错误。如：12: not found| docker-entrypoint.sh: 2: docker-entrypoint.sh:dockertypecho_php-fpm_1 exited with code 127 12 替换 Windows 换行符sed 命令在构建镜像的时候，使用 sed 命令把将要执行的脚本文件中的换行符全部替换。 Dockerfile 12ADD ./src/docker-entrypoint.sh /var/www/html/docker-entrypoint.shRUN sed -i &apos;s/\\r//g&apos; docker-entrypoint.sh","categories":[{"name":"Docker","slug":"Docker","permalink":"https://zh-h.github.io/categories/Docker/"},{"name":"Linux","slug":"Docker/Linux","permalink":"https://zh-h.github.io/categories/Docker/Linux/"}],"tags":[]},{"title":"Django REST Framework 01","slug":"111","date":"2017-05-15T01:43:00.000Z","updated":"2019-10-26T21:49:24.151Z","comments":true,"path":"2017/05/15/111/","link":"","permalink":"https://zh-h.github.io/2017/05/15/111/","excerpt":"","text":"1. View 中使用 多个路径参数 http://www.django-rest-framework.org/api-guide/generic-views/#creating-custom-mixins 12345678910111213class MultipleFieldLookupMixin(object): &quot;&quot;&quot; Apply this mixin to any view or viewset to get multiple field filtering based on a `lookup_fields` attribute, instead of the default single field filtering. &quot;&quot;&quot; def get_object(self): queryset = self.get_queryset() # Get the base queryset queryset = self.filter_queryset(queryset) # Apply any filter backends filter = &#123;&#125; for field in self.lookup_fields: if self.kwargs[field]: # Ignore empty fields. filter[field] = self.kwargs[field] return get_object_or_404(queryset, **filter) # Lookup the object 创建视图的时候使用这个混合类，创建的url包含account,username路径参数/(?P&lt;account&gt;.+)/(?P&lt;username&gt;.+)1234class RetrieveUserView(MultipleFieldLookupMixin, generics.RetrieveAPIView): queryset = User.objects.all() serializer_class = UserSerializer lookup_fields = (&apos;account&apos;, &apos;username&apos;) 覆盖授权123class UploadView(APIView): authentication_classes = (BasicAuthentication,) # 用其他认证类取消jwt的授权 permission_classes = (AllowAny,) 显示复数使用中文翻译的时候需要要指定复数命名，否则会自动在app label后面添加s12class Meta: verbose_name_plural = verbose_name","categories":[{"name":"Django","slug":"Django","permalink":"https://zh-h.github.io/categories/Django/"},{"name":"django rest framework","slug":"Django/django-rest-framework","permalink":"https://zh-h.github.io/categories/Django/django-rest-framework/"}],"tags":[]},{"title":"Docker 使用镜像源加速","slug":"2017/05/15/docker-registry-speed-up","date":"2017-05-14T16:00:00.000Z","updated":"2019-10-26T21:49:24.151Z","comments":true,"path":"2017/05/15/2017/05/15/docker-registry-speed-up/","link":"","permalink":"https://zh-h.github.io/2017/05/15/2017/05/15/docker-registry-speed-up/","excerpt":"","text":"使用镜像仓库12345678# Linuxsudo sed -i &quot;s|EXTRA_ARGS=&apos;|EXTRA_ARGS=&apos;--registry-mirror=http://d68f7922.m.daocloud.io |g&quot; /var/lib/boot2docker/profile# Toolboxdocker-machine ssh defaultsudo sed -i &quot;s|EXTRA_ARGS=&apos;|EXTRA_ARGS=&apos;--registry-mirror=http://d68f7922.m.daocloud.io |g&quot; /var/lib/boot2docker/profileexitdocker-machine restart default 基础系统镜像包管理加速如果使用基础的镜像，并且需要使用镜像系统的包管理工具，可以对包管理工具设置镜像源，加快构建速度。 Alpine Linux1RUN sed &quot;1i http://mirrors.ustc.edu.cn/alpine/v3.4/main/&quot; -if /etc/apk/repositories 中数字对应 Alpine 发行版本 Debian12345678910RUN cat &apos;&apos;&apos;deb http://mirrors.163.com/debian/ jessie main non-free contribdeb http://mirrors.163.com/debian/ jessie-updates main non-free contribdeb http://mirrors.163.com/debian/ jessie-backports main non-free contribdeb-src http://mirrors.163.com/debian/ jessie main non-free contribdeb-src http://mirrors.163.com/debian/ jessie-updates main non-free contribdeb-src http://mirrors.163.com/debian/ jessie-backports main non-free contribdeb http://mirrors.163.com/debian-security/ jessie/updates main non-free contribdeb-src http://mirrors.163.com/debian-security/ jessie/updates main non-free contrib&apos;&apos;&apos; &gt; /etc/apt/sources.list jessie 为对应的 Debian 版本","categories":[{"name":"Docker","slug":"Docker","permalink":"https://zh-h.github.io/categories/Docker/"},{"name":"Linux","slug":"Docker/Linux","permalink":"https://zh-h.github.io/categories/Docker/Linux/"}],"tags":[]},{"title":"开发环境常用的 Docker 镜像","slug":"2017/05/15/common-docker-cli","date":"2017-05-14T16:00:00.000Z","updated":"2019-10-26T21:49:24.151Z","comments":true,"path":"2017/05/15/2017/05/15/common-docker-cli/","link":"","permalink":"https://zh-h.github.io/2017/05/15/2017/05/15/common-docker-cli/","excerpt":"","text":"Portainer1docker run -d -p 10000:9000 --name=portainer --restart=always -v &quot;/var/run/docker.sock:/var/run/docker.sock&quot; portainer/portainer Postgresql1docker run --name docker-postgres -e POSTGRES_PASSWORD=adminadmin -e POSTGRES_USER=root -p 5432:5432 --restart=always -d postgres:9.6-alpine Pgadmin41docker run -d --name docker-pgadmin4 --restart always -p 5050:5050 --link docker-postgres chorss/docker-pgadmin4 MySQL1docker run --name docker-mysql --restart always -e MYSQL_ROOT_PASSWORD=adminadmin -p 3306:3306 -d mysql:5.7 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci PhpMyAdmin1docker run --name docker-phpmyadmin -d --link docker-mysql:db -p 3307:80 phpmyadmin/phpmyadmin Redis1docker run --name docker-redis -d -p 6379:6379 --restart always redis:3.2.9-alpine","categories":[{"name":"Docker","slug":"Docker","permalink":"https://zh-h.github.io/categories/Docker/"},{"name":"Linux","slug":"Docker/Linux","permalink":"https://zh-h.github.io/categories/Docker/Linux/"}],"tags":[]},{"title":"Nginx 禁止未绑定的域名访问","slug":"110","date":"2017-05-12T08:40:25.000Z","updated":"2019-10-26T21:49:24.150Z","comments":true,"path":"2017/05/12/110/","link":"","permalink":"https://zh-h.github.io/2017/05/12/110/","excerpt":"","text":"问题当设置了多个域名解析到同一个 IP 的 Nginx 服务器的时候，就会出现没有设置的域名也可以访问特定的站点，默认的 Nginx Vhost 配置会把没有匹配的域名请求指向到默认的default_server 解决 在nginx.conf配置中加入这一段默认的 server 配置 删除vhosts的default配置12345server &#123; listen 80 default_server; server_name _; return 444;&#125; 因为 Nginx 的 Vhost 会根据请求的域名去访问绑定了域名的站点，如果没有匹配到，就会去访问default_server 把default_server收到的请求都返回 444 Nginx 配置文件层级 1234567891011121314&#123; events &#123; &#125; http &#123; server &#123; upstream &#123; &#125; location &#123; # lalal &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://zh-h.github.io/tags/nginx/"},{"name":"Linux","slug":"Linux","permalink":"https://zh-h.github.io/tags/Linux/"}]},{"title":"HTTP 中 put 和 patch 的区别","slug":"109","date":"2017-05-12T08:10:00.000Z","updated":"2019-10-26T21:49:24.150Z","comments":true,"path":"2017/05/12/109/","link":"","permalink":"https://zh-h.github.io/2017/05/12/109/","excerpt":"","text":"在很多 RESTfull 应用中，会使用到POST 方法去创建内容， PUT 方法去更新内容，例如 1curl -x PUT /user/1 --data username=zonghua 但是经常混淆的是 PUT 和 PATCH 方法，从字面意义上理解就是，PUT 是重新放置， PATCH 进行局部修改。 当使用 id 做唯一主键的时候，就是 PUT 方法将一个指定 id 对象进行完全替换， PATCH 方法指定 id 去更新这个对象。 RFC 标准 https://tools.ietf.org/html/rfc5789#page-2 The difference between the PUT and PATCH requests is reflected in the way the server processes the enclosed entity to modify the resource identified by the Request-URI. In a PUT request, the enclosed entity is considered to be a modified version of the resource stored on the origin server, and the client is requesting that the stored version be replaced. With PATCH, however, the enclosed entity contains a set of instructions describing how a resource currently residing on the origin server should be modified to produce a new version. The PATCH method affects the resource identified by the Request-URI, and it also MAY have side effects on other resources; i.e., new resources may be created, or existing ones modified, by the application of a PATCH. 发现微信小程序不给用 PATCH 方法https://mp.weixin.qq.com/debug/wxadoc/dev/api/network-request.html#wxrequestobject 默认为 GET，有效值：OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://zh-h.github.io/categories/计算机基础/"},{"name":"rest","slug":"计算机基础/rest","permalink":"https://zh-h.github.io/categories/计算机基础/rest/"}],"tags":[]},{"title":"MySQL 按照 in 排序","slug":"108","date":"2017-04-21T19:36:27.000Z","updated":"2019-10-26T21:49:24.150Z","comments":true,"path":"2017/04/22/108/","link":"","permalink":"https://zh-h.github.io/2017/04/22/108/","excerpt":"","text":"12345678910mysql&gt; select * from auth_permission where id in (23, 4,12, 4,1);+----+----------------------------+-----------------+-----------------------+| id | name | content_type_id | codename |+----+----------------------------+-----------------+-----------------------+| 1 | Can add bookmark | 1 | add_bookmark || 4 | Can add pinned application | 2 | add_pinnedapplication || 12 | Can delete permission | 4 | delete_permission || 23 | Can change session | 8 | change_session |+----+----------------------------+-----------------+-----------------------+4 rows in set (0.00 sec) 默认in查询结果集都会使用id排序 1. 使用field函数 FIELD(str,str1,str2,str3,…)Returns the index (position) of str in the str1, str2, str3, … list. Returns 0 if str is not found. 12345678910mysql&gt; select * from auth_permission where id in (23, 4,12, 4,1) order by field(id,23,4,12,4,1);+----+----------------------------+-----------------+-----------------------+| id | name | content_type_id | codename |+----+----------------------------+-----------------+-----------------------+| 23 | Can change session | 8 | change_session || 4 | Can add pinned application | 2 | add_pinnedapplication || 12 | Can delete permission | 4 | delete_permission || 1 | Can add bookmark | 1 | add_bookmark |+----+----------------------------+-----------------+-----------------------+4 rows in set (0.00 sec) 2. 使用关联查询","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://zh-h.github.io/categories/MySQL/"}],"tags":[]},{"title":"不想上班","slug":"107","date":"2017-04-19T05:41:58.000Z","updated":"2019-10-26T21:49:24.150Z","comments":true,"path":"2017/04/19/107/","link":"","permalink":"https://zh-h.github.io/2017/04/19/107/","excerpt":"","text":"不想上班","categories":[{"name":"默认分类","slug":"默认分类","permalink":"https://zh-h.github.io/categories/默认分类/"}],"tags":[]},{"title":"教务系统爬虫的微信小程序","slug":"81","date":"2017-03-28T23:49:00.000Z","updated":"2019-10-26T21:49:24.159Z","comments":true,"path":"2017/03/29/81/","link":"","permalink":"https://zh-h.github.io/2017/03/29/81/","excerpt":"","text":"之前在路由器上装的 node.js 运行环境运行的一个抓取脚本现在派上用了。 那么问题来了1. GBK 编码 首先要解决的教务系统网站 GBK 编码问题，参考过去的记录 《node get post提交中文参数》 更新发现微信的 wx.request(OBJECT) API 可以直接向 GBK 网站请求，返回的就是 UTF8 字符12345678910111213wx.request(&#123; url: &apos;test.php&apos;, data: &#123; x: &apos;&apos; , y: &apos;&apos; &#125;, header: &#123; &apos;Content-Type&apos;: &apos;application/json&apos; &#125;, success: function(res) &#123; console.log(res.data) // 自动编码转换 &#125;&#125;) 2. 使用 npm packageMINA 框架带有require函数加载依赖，但并不是完整的 CommonJS，require 函数仅仅能够加载项目中的文件，而且必须严格定义 JS 文件路径，路径不支持 CommonJS 的路径风格。 需要直接使用相对路径，并且需要指定后缀。1require(&apos;node_modules/lodash/map.js&apos;); 3. 获取二进制的图片对象内置的 wx.request(OBJECT) 对象只有返回 Date 和 errorMSg 无法满足需求。 还好 JScore 环境依然提供了本地的 XMLHttpRequest 对象，可以直接调用原生办法。123456789101112131415161718var getBase64File = function( url, callback ) &#123; var xhr = new XMLHttpRequest(); xhr.responseType = &apos;blob&apos;; xhr.onload = function() &#123; var reader = new FileReader(); reader.onloadend = function() &#123; var headers = xhr.getAllResponseHeaders(); callback( reader.result, headers ); &#125; reader.readAsDataURL( xhr.response ); &#125;; xhr.open( &apos;GET&apos;, url ); xhr.send();&#125;getBase64(&apos;test.jpg&apos;, function (base64, headers)&#123; console.log(headers);&#125; 4. 微信小程序跨域限制这是从 Chrome 控制台看到的响应头12345678910HTTP/1.1 200 OKDate: Fri, 30 Sep 2016 12:46:33 GMTServer: Microsoft-IIS/6.0MicrosoftOfficeWebServer: 5.0_PubX-Powered-By: ASP.NETX-AspNet-Version: 1.1.4322Set-Cookie: ASP.NET_SessionId=hw4tpo55f4005ojii14d2e3r; path=/Cache-Control: privateContent-Type: image/Gif; charset=gb2312Content-Length: 2245 这是从 XMLHttpRequest.getAllResponseHeaders() 获取到的信息12345678910Date: Fri, 30 Sep 2016 12:46:33 GMTServer: Microsoft-IIS/6.0X-AspNet-Version: 1.1.4322X-Powered-By: ASP.NETMicrosoftOfficeWebServer: 5.0_PubContent-Type: image/Gif; charset=gb2312Access-Control-Allow-Origin: *Cache-Control: privateAccess-Control-Allow-Headers: X-Requested-With, Content-TypeContent-Length: 2245 浏览器同源策略，为了安全，同源策略限制了一个源（origin）中加载文本或脚本与来自其它源（origin）中资源的交互方式 CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。 因为跨域限制，暂时没找到小程序去获取 Cookie 的办法，当然这里指的是是仅仅依靠小程序而不依赖自己的应用服务器去处理的情况（实际上小程序也不应当有过多的逻辑处理，仅仅当作一个显示的层面）。 5. Nginx 反向代理解决跨域问题参考阮一峰的《跨域资源共享 CORS 详解》 解决方案是在服务端响应头加入允许跨域的字段说明123456location ~/ &#123; add_header &apos;Access-Control-Allow-Origin&apos; &apos;https://docs.domain.com&apos;; add_header &apos;Access-Control-Allow-Credentials&apos; &apos;true&apos;; add_header &apos;Access-Control-Allow-Methods&apos; &apos;GET, POST, PUT, DELETE, PATCH, OPTIONS&apos;; proxy_pass http://target.com;&#125; 如果需要匹配所有访问域名可以使用 add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39; 还是写个服务端吧，客户端不适合做这么多处理黑客马拉松 这几天参加了 ifanr 和 segmentfault 举办的未来小程序为主题的和黑客马拉松活动，作为一名志愿者围观了几十位参赛选手的开发过程，见识到了八个短短二十个小时内完成的设计别出心裁新颖的项目。 关于技术： ECMAScript 6 在 iOS 10 上出现兼容问题问题，模拟器上运行正常，真机演示却出现了问题； 限制访问域名，只有五个安全域名可以授权，可能需要反代解决外部资源引用的问题； 突出“小”的内容，微信小程序限制打包资源 1MB，如果使用图片资源最好使用矢量图或者使用适当的压缩，如果使用外部资源，也只能够提供 5MB 的本地存储，过多的资源也会导致首次使用的时候加载过慢； 由于还是在内测阶段，内置的地图控件（原生控件，不在 WebView）仅仅开放提供了定位显示的功能，根本无法添加其他视图层实现地理标签等功能 无关技术： 场地很有互联网公司的范，绿树掩映、陈旧厂房、新潮装修、文艺十足； 有一半参赛选手是学生，大一的新生表现突出，可见微信的想象力宽泛，早早影响到了初生代","categories":[{"name":"默认分类","slug":"默认分类","permalink":"https://zh-h.github.io/categories/默认分类/"},{"name":"微信小程序","slug":"默认分类/微信小程序","permalink":"https://zh-h.github.io/categories/默认分类/微信小程序/"}],"tags":[]},{"title":"使用 Shipyar 管理 Docker","slug":"102","date":"2017-03-14T23:02:00.000Z","updated":"2019-10-26T21:49:24.150Z","comments":true,"path":"2017/03/15/102/","link":"","permalink":"https://zh-h.github.io/2017/03/15/102/","excerpt":"","text":"Shipyard是一个集成管理 Docker 容器、镜像、镜像仓库的系统，相比较于 Docker 出品的 Swarm，Shipyard可以使用多个节点调度管理，可以动态加载节点，可以托管各个节点下的容器。官方文档https://shipyard-project.com/docs/deploy/automated/ 1. 首次部署脚本1curl -sSL https://shipyard-project.com/deploy | bash -s ACTION: 可以使用的指令 (deploy, upgrade, node, remove)DISCOVERY: 集群系统采用Swarm进行采集和管理(在节点管理中可以使用‘node’)IMAGE: 镜像，默认使用shipyard的镜像PREFIX: 容器名字的前缀SHIPYARD_ARGS: 容器的常用参数TLS_CERT_PATH: TLS证书路径PORT: 主程序监听端口 (默认端口: 8080)PROXY_PORT: 代理端口 (默认: 2375) 1.1 脚本可选项 action：指令有效变量deploy: 部署新的shipyard实例upgrade: 更新已存在的实例（注意：你要保持相同的系统环境、变量来部署同样的配置）node: 使用Swarm增加一个新的node ……3. 增加一个节点Shipyard节点部署脚本可以自动的安装 key/value 存储系统（etcd系统）。在将要被添加的节点主机上执行脚本增加一个节点到swarm集群1curl -sSL https://shipyard-project.com/deploy | ACTION=node DISCOVERY=etcd://applehater.cn:4001 bash -s 其中DISCOVERY是你运行 Shipyard 容器的域名或者地址 4. 操作 创建容器 容器列表 查看某个容器状态 没办法变更容器配置这可能是最大弊端，无法找到变更配置的控制面板，如果创建 mysql 容器的时候忘记配置初始密码，可肯需要重新创建。像 Rancher 这样的平台可以自由对容器配置扩展，建立应用堆栈 5. 移除使用以下脚本移除 Shipyard Agent 或者 Shipyard Node1curl -sSL https://shipyard-project.com/deploy | ACTION=remove bash -s","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zh-h.github.io/categories/Linux/"},{"name":"docker","slug":"Linux/docker","permalink":"https://zh-h.github.io/categories/Linux/docker/"}],"tags":[]},{"title":"有关 Django 的一些","slug":"101","date":"2017-03-05T22:38:00.000Z","updated":"2019-10-26T21:49:24.150Z","comments":true,"path":"2017/03/06/101/","link":"","permalink":"https://zh-h.github.io/2017/03/06/101/","excerpt":"","text":"1. 时区设置python默认时区会根据系统的时区设置，如果没有设置，插入数据表的数据将出现时区错误，造成一些时间判断上的偏差123456789LANGUAGE_CODE = &apos;zh-hans&apos;TIME_ZONE = &apos;Asia/Shanghai&apos;USE_I18N = TrueUSE_L10N = TrueUSE_TZ = True 2. fixtures在项目根目录执行1./manage.py dumpdata &gt; data.json 载入12./manage.py migrate./manage.py loaddata data.json 注意要将当中包含contenttype和permission的数据去掉，避免Duplicate entry错误，因为已经在migrate过程中创建了 3. 数据库编码如果数据编码使用了utf8mb4*之类的编码，会导致Django的Model的datetime类型全部会None。请使用非utf8mb4编码 4. 设置全局变量 设置管理后台名称12345#coding:utf8from django.contrib import admin admin.AdminSite.site_header =&apos;devops&apos;admin.AdminSite.site_title = &apos;devops&apos; 5. model自关联因为Python成员内不能应用类名,因此需要使用self字符去关联自身的外键.12345class Plot(models.Model): name = models.Charfield() address = models.Charfield() area = models.DecimalField() parent_plot = models.ForeignKey(&apos;self&apos;, related_name=&apos;subplots&apos;) 6. django-select212345678910111213class EmployeeChoices(AutoModelSelect2Field): fname = FirstName() queryset = [(1,&apos;value 1&apos;)]#fname.getAllNames() search_fields = [&apos;name__icontains&apos;,]field_name = EmployeeChoices( required=False, widget=AutoHeavySelect2Widget( select2_options=&#123; &apos;placeholder&apos;: u&quot;Select a choice&quot; &#125; ), label=&apos;&apos;)","categories":[{"name":"Django","slug":"Django","permalink":"https://zh-h.github.io/categories/Django/"}],"tags":[]},{"title":"MQTT 话题匹配算法实现","slug":"100","date":"2017-03-04T19:27:00.000Z","updated":"2019-10-26T21:49:24.150Z","comments":true,"path":"2017/03/05/100/","link":"","permalink":"https://zh-h.github.io/2017/03/05/100/","excerpt":"","text":"MQTT 协议的订阅的话题名称采用修改版UTF-8编码，订阅者的话题支持通配符#和+ 用户需要一次订阅多个具有类似结构的话题，可以在话题过滤器中包含通配符。通配符只可用在话题过滤器中，在发布应用消息时的话题名不允许包含通配符，话题通配符有两种： #：表示匹配&gt;=0个层次，比如a/#就匹配a/b，a/b/c（不能匹配a/，后面必须有其它话题）。单独的一个#表示匹配所有，不允许a#或a/#/c等形式。 +：表示匹配一个层次，例如a/+匹配a/b，a/c，不匹配a/b/c。单独的一个+是允许的，但a+为非法形式。 1. 实现一 先使用排列组合生成有可能匹配的所有话题模式，然后放置到Object中，在这里当只有唯一元素的Set使用 在目标话题中直接查找，如果在所有话题模式中包含这个目标话题，就返回真。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&quot;use strict&quot;;var LRU = require(&quot;lru-cache&quot;);var logger = require(&apos;./logHelper&apos;).logger(__filename)var cache = LRU(&#123; max: 10000, maxAge: 1000 * 60 * 60&#125;);/** * Generate the possible patterns that might match a topic. * * @param &#123;String&#125; the topic * @return the object of the patterns */function _topicPatterns(topic) &#123; var parts = topic.split(&quot;/&quot;); var patterns = &#123;&#125;; patterns[topic] = true var i, a = [], b = [], j, k, h, list = []; for (j = 1; j &lt; parts.length; j++) &#123; list.length = 0; // clear the array for (i = 0; i &lt; parts.length; i++) &#123; a.length = 0; b.length = 0; list.push(i); for (h = 1; list.length &lt; j; h++) &#123; list.unshift(parts.length - h); &#125; for (k = 0; k &lt; parts.length; k++) &#123; if (list.indexOf(k) &gt;= 0) &#123; a.push(parts[k]); b.push(parts[k]); &#125; else &#123; if (k === 0 || a[a.length - 1] !== &quot;#&quot;) &#123; a.push(&quot;#&quot;); &#125; b.push(&quot;+&quot;); &#125; &#125; patterns[(a.join(&quot;/&quot;))] = true; patterns[(b.join(&quot;/&quot;))] = true; list.shift(); &#125; &#125; return patterns;&#125;/** * Generate the possible patterns that might match a topic. * Memozied version. * * @param &#123;String&#125; the topic * @return the map of the patterns */function topicPatterns(topic) &#123; var result = cache.get(topic); if (!result) &#123; result = _topicPatterns(topic); &#125; cache.set(topic, result); return result;&#125;/** * 根据输入的话题匹配目标话题列表，匹配成功就返回true * 使用lur缓存，现在有BUG，只能匹配/开头的话题 * * @param &#123;String&#125; 输入的话题 * @param &#123;list&#125; 目标话题 */function match(topic, targetTopics) &#123; var possibles = topicPatterns(topic); logger.debug(&apos;possible topic patterns: &apos;) logger.debug(possibles) for (var i = 0; i &lt; targetTopics.length; i++) &#123; var targetTopic = targetTopics[i]; if (possibles[targetTopic]) &#123; logger.debug(&apos;Topic match: %s&apos;, true) return true; &#125; &#125; logger.debug(&apos;Topic match: %s&apos;, false) return false;&#125;module.exports.match = match;module.exports.topicPatterns = topicPatterns 测试1234567891011121314function testMatch() &#123; var subscribeTopics = [&apos;/a/sdfsdfds/u/sdfsdf/#&apos;] var publishTopic = &apos;/a1/sdfsdfds/u/sdfsdf/12222&apos; var result = match(publishTopic, subscribeTopics) console.log(result==false) var result = match(&apos;/a/sdfsdfds/u/sdfsdf/12222&apos;, subscribeTopics) console.log(result==false)&#125; 输出123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127[2017-03-05 11:31:40.157] [DEBUG] file - possible topic patterns: [2017-03-05 11:31:40.158] [DEBUG] file - &#123; &apos;/a1/sdfsdfds/u/sdfsdf/12222&apos;: true, &apos;/#&apos;: true, &apos;/+/+/+/+/+&apos;: true, &apos;#/a1/#&apos;: true, &apos;+/a1/+/+/+/+&apos;: true, &apos;#/sdfsdfds/#&apos;: true, &apos;+/+/sdfsdfds/+/+/+&apos;: true, &apos;#/u/#&apos;: true, &apos;+/+/+/u/+/+&apos;: true, &apos;#/sdfsdf/#&apos;: true, &apos;+/+/+/+/sdfsdf/+&apos;: true, &apos;#/12222&apos;: true, &apos;+/+/+/+/+/12222&apos;: true, &apos;/#/12222&apos;: true, &apos;/+/+/+/+/12222&apos;: true, &apos;/a1/#&apos;: true, &apos;/a1/+/+/+/+&apos;: true, &apos;#/a1/sdfsdfds/#&apos;: true, &apos;+/a1/sdfsdfds/+/+/+&apos;: true, &apos;#/sdfsdfds/u/#&apos;: true, &apos;+/+/sdfsdfds/u/+/+&apos;: true, &apos;#/u/sdfsdf/#&apos;: true, &apos;+/+/+/u/sdfsdf/+&apos;: true, &apos;#/sdfsdf/12222&apos;: true, &apos;+/+/+/+/sdfsdf/12222&apos;: true, &apos;/#/sdfsdf/12222&apos;: true, &apos;/+/+/+/sdfsdf/12222&apos;: true, &apos;/a1/#/12222&apos;: true, &apos;/a1/+/+/+/12222&apos;: true, &apos;/a1/sdfsdfds/#&apos;: true, &apos;/a1/sdfsdfds/+/+/+&apos;: true, &apos;#/a1/sdfsdfds/u/#&apos;: true, &apos;+/a1/sdfsdfds/u/+/+&apos;: true, &apos;#/sdfsdfds/u/sdfsdf/#&apos;: true, &apos;+/+/sdfsdfds/u/sdfsdf/+&apos;: true, &apos;#/u/sdfsdf/12222&apos;: true, &apos;+/+/+/u/sdfsdf/12222&apos;: true, &apos;/#/u/sdfsdf/12222&apos;: true, &apos;/+/+/u/sdfsdf/12222&apos;: true, &apos;/a1/#/sdfsdf/12222&apos;: true, &apos;/a1/+/+/sdfsdf/12222&apos;: true, &apos;/a1/sdfsdfds/#/12222&apos;: true, &apos;/a1/sdfsdfds/+/+/12222&apos;: true, &apos;/a1/sdfsdfds/u/#&apos;: true, &apos;/a1/sdfsdfds/u/+/+&apos;: true, &apos;#/a1/sdfsdfds/u/sdfsdf/#&apos;: true, &apos;+/a1/sdfsdfds/u/sdfsdf/+&apos;: true, &apos;#/sdfsdfds/u/sdfsdf/12222&apos;: true, &apos;+/+/sdfsdfds/u/sdfsdf/12222&apos;: true, &apos;/#/sdfsdfds/u/sdfsdf/12222&apos;: true, &apos;/+/sdfsdfds/u/sdfsdf/12222&apos;: true, &apos;/a1/#/u/sdfsdf/12222&apos;: true, &apos;/a1/+/u/sdfsdf/12222&apos;: true, &apos;/a1/sdfsdfds/#/sdfsdf/12222&apos;: true, &apos;/a1/sdfsdfds/+/sdfsdf/12222&apos;: true, &apos;/a1/sdfsdfds/u/#/12222&apos;: true, &apos;/a1/sdfsdfds/u/+/12222&apos;: true, &apos;/a1/sdfsdfds/u/sdfsdf/#&apos;: true, &apos;/a1/sdfsdfds/u/sdfsdf/+&apos;: true, &apos;#/a1/sdfsdfds/u/sdfsdf/12222&apos;: true, &apos;+/a1/sdfsdfds/u/sdfsdf/12222&apos;: true &#125;[2017-03-05 11:31:40.161] [DEBUG] file - Topic match: false[2017-03-05 11:33:18.170] [DEBUG] file - possible topic patterns: [2017-03-05 11:33:18.173] [DEBUG] file - &#123; &apos;/a/sdfsdfds/u/sdfsdf/12222&apos;: true, &apos;/#&apos;: true, &apos;/+/+/+/+/+&apos;: true, &apos;#/a/#&apos;: true, &apos;+/a/+/+/+/+&apos;: true, &apos;#/sdfsdfds/#&apos;: true, &apos;+/+/sdfsdfds/+/+/+&apos;: true, &apos;#/u/#&apos;: true, &apos;+/+/+/u/+/+&apos;: true, &apos;#/sdfsdf/#&apos;: true, &apos;+/+/+/+/sdfsdf/+&apos;: true, &apos;#/12222&apos;: true, &apos;+/+/+/+/+/12222&apos;: true, &apos;/#/12222&apos;: true, &apos;/+/+/+/+/12222&apos;: true, &apos;/a/#&apos;: true, &apos;/a/+/+/+/+&apos;: true, &apos;#/a/sdfsdfds/#&apos;: true, &apos;+/a/sdfsdfds/+/+/+&apos;: true, &apos;#/sdfsdfds/u/#&apos;: true, &apos;+/+/sdfsdfds/u/+/+&apos;: true, &apos;#/u/sdfsdf/#&apos;: true, &apos;+/+/+/u/sdfsdf/+&apos;: true, &apos;#/sdfsdf/12222&apos;: true, &apos;+/+/+/+/sdfsdf/12222&apos;: true, &apos;/#/sdfsdf/12222&apos;: true, &apos;/+/+/+/sdfsdf/12222&apos;: true, &apos;/a/#/12222&apos;: true, &apos;/a/+/+/+/12222&apos;: true, &apos;/a/sdfsdfds/#&apos;: true, &apos;/a/sdfsdfds/+/+/+&apos;: true, &apos;#/a/sdfsdfds/u/#&apos;: true, &apos;+/a/sdfsdfds/u/+/+&apos;: true, &apos;#/sdfsdfds/u/sdfsdf/#&apos;: true, &apos;+/+/sdfsdfds/u/sdfsdf/+&apos;: true, &apos;#/u/sdfsdf/12222&apos;: true, &apos;+/+/+/u/sdfsdf/12222&apos;: true, &apos;/#/u/sdfsdf/12222&apos;: true, &apos;/+/+/u/sdfsdf/12222&apos;: true, &apos;/a/#/sdfsdf/12222&apos;: true, &apos;/a/+/+/sdfsdf/12222&apos;: true, &apos;/a/sdfsdfds/#/12222&apos;: true, &apos;/a/sdfsdfds/+/+/12222&apos;: true, &apos;/a/sdfsdfds/u/#&apos;: true, &apos;/a/sdfsdfds/u/+/+&apos;: true, &apos;#/a/sdfsdfds/u/sdfsdf/#&apos;: true, &apos;+/a/sdfsdfds/u/sdfsdf/+&apos;: true, &apos;#/sdfsdfds/u/sdfsdf/12222&apos;: true, &apos;+/+/sdfsdfds/u/sdfsdf/12222&apos;: true, &apos;/#/sdfsdfds/u/sdfsdf/12222&apos;: true, &apos;/+/sdfsdfds/u/sdfsdf/12222&apos;: true, &apos;/a/#/u/sdfsdf/12222&apos;: true, &apos;/a/+/u/sdfsdf/12222&apos;: true, &apos;/a/sdfsdfds/#/sdfsdf/12222&apos;: true, &apos;/a/sdfsdfds/+/sdfsdf/12222&apos;: true, &apos;/a/sdfsdfds/u/#/12222&apos;: true, &apos;/a/sdfsdfds/u/+/12222&apos;: true, &apos;/a/sdfsdfds/u/sdfsdf/#&apos;: true, &apos;/a/sdfsdfds/u/sdfsdf/+&apos;: true, &apos;#/a/sdfsdfds/u/sdfsdf/12222&apos;: true, &apos;+/a/sdfsdfds/u/sdfsdf/12222&apos;: true &#125;[2017-03-05 11:33:18.179] [DEBUG] file - Topic match: true 实现二把话题路径中的#和+替换成语言内置的正则语法，然后进行匹配1234567var matchTopic = function(inputTopic, targetTopic) &#123; if (inputTopic== &quot;#&quot;) &#123; return true; &#125; var re = new RegExp(&quot;^&quot;+inputTopic.replace(/([\\[\\]\\?\\(\\)\\\\\\\\$\\^\\*\\.|])/g,&quot;\\\\$1&quot;).replace(/\\+/g,&quot;[^/]+&quot;).replace(/\\/#$/,&quot;(\\/.*)?&quot;)+&quot;$&quot;); return re.test(targetTopic); &#125;;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zh-h.github.io/categories/数据结构与算法/"},{"name":"mqtt","slug":"数据结构与算法/mqtt","permalink":"https://zh-h.github.io/categories/数据结构与算法/mqtt/"}],"tags":[]},{"title":"Nginx 关闭站点访问规则","slug":"99","date":"2017-02-27T19:45:37.000Z","updated":"2019-10-26T21:49:24.160Z","comments":true,"path":"2017/02/28/99/","link":"","permalink":"https://zh-h.github.io/2017/02/28/99/","excerpt":"","text":"123456789101112131415161718192021222324252627server &#123; listen 80 ; index index.html index.htm; add_header Content-Type &quot;text/html; charset=utf-8&quot;; server_name applehater.cn; gzip on; gzip_vary on; gzip_comp_level 4; gzip_buffers 16 8k; gzip_min_length 1000; gzip_proxied any; gzip_disable &quot;msie6&quot;; gzip_http_version 1.0; gzip_types text/html text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript application/javascript image/svg+xml;# location / &#123;# proxy_set_header X-Real-IP $remote_addr;# proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;# proxy_set_header Host $http_host;# proxy_set_header X-NginX-Proxy true;# proxy_pass http://localhost:8087/;# &#125; # 不区分大小写任意URL匹配，都访问到以下的文件 location ~.* &#123; alias /www/applehater.cn/public/index.html; &#125;&#125;","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://zh-h.github.io/tags/nginx/"},{"name":"Linux","slug":"Linux","permalink":"https://zh-h.github.io/tags/Linux/"}]},{"title":"Spring Boot application always hang at the following point","slug":"96","date":"2017-01-13T00:15:00.000Z","updated":"2019-10-26T21:49:24.160Z","comments":true,"path":"2017/01/13/96/","link":"","permalink":"https://zh-h.github.io/2017/01/13/96/","excerpt":"","text":"problem12014-12-22 23:26:58.957 INFO 1 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean : Mapping filter: &apos;hiddenHttpMethodFilter&apos; to: [/*] solution1apt-get install haveged -y 1nohup java -Djava.security.egd=file:/dev/./urandom -jar *.jar &gt; /dev/null &amp;","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"}],"tags":[]},{"title":"交集","slug":"95","date":"2016-12-26T03:54:08.000Z","updated":"2019-10-26T21:49:24.160Z","comments":true,"path":"2016/12/26/95/","link":"","permalink":"https://zh-h.github.io/2016/12/26/95/","excerpt":"","text":"1. 哈希查找时间 O(n) 空间 O(m+n)123456789101112131415int ComNum_Hash(int a[],int lenA,int b[],int lenB,int *comlst)&#123; int hashTb[MAX_INT] = &#123;0&#125;,i,j,k=0; for(i = 0; i &lt; lenA; i++) hashTb[a[i]] = 1; for(j = 0; j &lt; lenB; j++) &#123; if(hashTb[b[j]] == 1) comlst[k++] = b[j]; &#125; return k;&#125; Java 直接调用1234567891011List&lt;String&gt; list1 = new ArrayList&lt;String&gt;(); List&lt;String&gt; list2 = new ArrayList&lt;String&gt;(); list1.add(&quot;g&quot;); list1.add(&quot;s&quot;); list1.add(&quot;a&quot;); list1.add(&quot;f&quot;); list2.add(&quot;g&quot;); list2.add(&quot;c&quot;); list2.add(&quot;b&quot;); list2.add(&quot;a&quot;); list1.retainAll(list2); 2. 二路归并时间O(nlog2n) 空间O(n)123456789101112int count()&#123;total=i=j=0;while(i&lt;n &amp;&amp; j&lt;n)&#123;if(a[i]&lt;b[j]) i++;else if(a[i]&gt;b[j])j++else total++;&#125; return total;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zh-h.github.io/categories/数据结构与算法/"}],"tags":[]},{"title":"Nginx 反向代理前后端分离 Cookie 路径重写","slug":"94","date":"2016-12-24T22:25:00.000Z","updated":"2019-10-26T21:49:24.160Z","comments":true,"path":"2016/12/25/94/","link":"","permalink":"https://zh-h.github.io/2016/12/25/94/","excerpt":"","text":"1. 场景luiliuliu为 Java 项目，打包成 war 放置在 tomcat 运行，端口 9090； Web 前端为 Vue 工程，SPA 一次加载页面资源，数据通过 vue-resource 向后端取数据，后端路径在开发环境已经映射为http://localhost/web/ 如果简单使用反向代理，会导致后端设置的 cookie 路径多了一条luiliuliu，由于 cookie 的安全设置，不同来源前端请求是取不到这样的 cookie 2. 解决123456789location /web/ &#123; proxy_pass http://127.0.0.1:9090/luiliuliu/; proxy_cookie_path /phonecook/ /; # 重写路径 proxy_set_header Host $host; proxy_set_header Remote_Addr $remote_addr; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; 去掉cookie的路径1Set-Cookie:JSESSIONID=13C147CE3B1105465BC5CED280EF364C; Path=/luiliuliu/; HttpOnly 变成1Set-Cookie:JSESSIONID=5B247D5F4DDC0CE2BE8458D0F1C037CA; admin=adminadmin","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://zh-h.github.io/tags/nginx/"},{"name":"Linux","slug":"Linux","permalink":"https://zh-h.github.io/tags/Linux/"},{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/tags/Java/"}]},{"title":"ESP8266 实现 Http 服务器控制 IO","slug":"91","date":"2016-12-17T07:22:00.000Z","updated":"2019-10-26T21:49:24.160Z","comments":true,"path":"2016/12/17/91/","link":"","permalink":"https://zh-h.github.io/2016/12/17/91/","excerpt":"","text":"ESP8266是一块由乐鑫espressif设计的wifi芯片，虽然它的定位是个Wi-Fi网络解决方案，但它更像一个物联网解决方案。它不仅体积小——大概11*10毫米左右，而且造价便宜，一个ESP8266的集成板只需要十几块。 ESP8266的核心是一块Diamond Standard 106Micro控制器，一个低功耗的32位RISC控制器。它拥有GPIO、I2C、ADC、SPI、PWM等模块，你可以用它做一些微控制器能做的事。它还可以支持AP（Access Point）、STA（Station）、AP+STA共存模式，并且使用高效的AT指令。 如同官方所示，它还具有下面的一些特性： SDIO 2.0、SPI、UART 接口 32-pin QFN 封装 集成 RF 开关、 balun、LNA、 24 dBm PA 、DCXO 和 电源管理单元（PMU） 集成 RISC 处理器、片上存储器和外部存储器接口 集成 MAC/基带处理器 高品质的服务管理 高保真音频应用所需的 I2S 接口 所有内部供电均包含片上低压差线性稳压器 专有的无杂散时钟生成架构 集成 WEP、 TKIP、AES 和 WAPI 引擎 工作温度范围：-40C ~ 125C 因此可以用它来实现一些很有趣的东西，包括但不限于这里的 http 服务 NodeMCUNodeMCU 是一个嵌入式固件，可以在上面运行 Lua 脚本程序进行连接网络，控制IO 引线主要用到 GPIO0 GPIO1 去驱动外部电路 固件烧录参考教程 http://www.bigiot.net/talk/9.html Lua Script123456789101112131415161718192021222324252627282930313233343536373839wifi.setmode(wifi.STATION)wifi.sta.config(&quot;YOUR_NETWORK_NAME&quot;,&quot;YOUR_NETWORK_PASSWORD&quot;)print(wifi.sta.getip())led1 = 3led2 = 4gpio.mode(led1, gpio.OUTPUT)gpio.mode(led2, gpio.OUTPUT)srv=net.createServer(net.TCP)srv:listen(80,function(conn) conn:on(&quot;receive&quot;, function(client,request) local buf = &quot;&quot;; local _, _, method, path, vars = string.find(request, &quot;([A-Z]+) (.+)?(.+) HTTP&quot;); if(method == nil)then _, _, method, path = string.find(request, &quot;([A-Z]+) (.+) HTTP&quot;); end local _GET = &#123;&#125; if (vars ~= nil)then for k, v in string.gmatch(vars, &quot;(%w+)=(%w+)&amp;*&quot;) do _GET[k] = v end end buf = buf..&quot;&lt;h1&gt; ESP8266 Web Server&lt;/h1&gt;&quot;; buf = buf..&quot;&lt;p&gt;GPIO0 &lt;a href=\\&quot;?pin=ON1\\&quot;&gt;&lt;button&gt;ON&lt;/button&gt;&lt;/a&gt;&amp;nbsp;&lt;a href=\\&quot;?pin=OFF1\\&quot;&gt;&lt;button&gt;OFF&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;&quot;; buf = buf..&quot;&lt;p&gt;GPIO2 &lt;a href=\\&quot;?pin=ON2\\&quot;&gt;&lt;button&gt;ON&lt;/button&gt;&lt;/a&gt;&amp;nbsp;&lt;a href=\\&quot;?pin=OFF2\\&quot;&gt;&lt;button&gt;OFF&lt;/button&gt;&lt;/a&gt;&lt;/p&gt;&quot;; local _on,_off = &quot;&quot;,&quot;&quot; if(_GET.pin == &quot;ON1&quot;)then gpio.write(led1, gpio.HIGH); elseif(_GET.pin == &quot;OFF1&quot;)then gpio.write(led1, gpio.LOW); elseif(_GET.pin == &quot;ON2&quot;)then gpio.write(led2, gpio.HIGH); elseif(_GET.pin == &quot;OFF2&quot;)then gpio.write(led2, gpio.LOW); end client:send(buf); client:close(); collectgarbage(); end)end) 上传脚本参考 http://blog.csdn.net/leytton/article/details/51723221 访问运行在路由器上找到你的设备地址，例如访问 http://192.168.1.232 点击按钮即可控制接口输出！参考链接 http://randomnerdtutorials.com/esp8266-web-server/","categories":[{"name":"IoT","slug":"IoT","permalink":"https://zh-h.github.io/categories/IoT/"},{"name":"esp8266","slug":"IoT/esp8266","permalink":"https://zh-h.github.io/categories/IoT/esp8266/"}],"tags":[]},{"title":"Ngrok 快速编译配置","slug":"90","date":"2016-12-12T07:14:27.000Z","updated":"2019-10-26T21:49:24.160Z","comments":true,"path":"2016/12/12/90/","link":"","permalink":"https://zh-h.github.io/2016/12/12/90/","excerpt":"","text":"域名解析dev.applehater.cn 解析A记录到服务器 *.dev.applehater.cn 解析A记录到服务器 不使用泛域名就只能指定若干固定域名，以下配置将会使用到域名 以下步骤均使用 root 权限执行 编译安装编译过程可能需要下载蔷外的资源，请做好准备。 1. 安装 Go 环境1234wget https://storage.googleapis.com/golang/go1.7.4.linux-amd64.tar.gz \\&amp;&amp; tar -xvf go1.7.4.linux-amd64.tar.gz -C /usr/local \\&amp;&amp; export GOROOT=/usr/local/go \\&amp;&amp; export PATH=$GOROOT/bin:$PATH 1go version 2. 安装 Ngrok创建目录 123mkdir /opt/ngrokcd /opt/ngrokgit clone https://github.com/inconshreveable/ngrok.git 生成密钥12cd ngrokexport NGROK_DOMAIN=&quot;dev.applehater.cn&quot; #设置你的域名 一行执行123456openssl genrsa -out base.key 2048 \\&amp;&amp; openssl req -new -x509 -nodes -key base.key -days 10000 -subj &quot;/CN=$NGROK_DOMAIN&quot; -out base.pem \\&amp;&amp; openssl genrsa -out server.key 2048 \\&amp;&amp; openssl req -new -key server.key -subj &quot;/CN=$NGROK_DOMAIN&quot; -out server.csr \\&amp;&amp; openssl x509 -req -in server.csr -CA base.pem -CAkey base.key -CAcreateserial -days 10000 -out server.crt \\&amp;&amp; cp base.pem assets/client/tls/ngrokroot.crt 编译1234GOOS=linux GOARCH=amd64 make release-server \\&amp;&amp; GOOS=linux GOARCH=amd64 make release-client \\&amp;&amp; GOOS=windows GOARCH=amd64 make release-client \\&amp;&amp; GOOS=darwin GOARCH=amd64 make release-client 运行1nohup ./bin/ngrokd -domain=&quot;dev.applehater.cn&quot; -tlsKey=server.key -tlsCrt=keserver.crt -httpAddr=&quot;:9000&quot; -httpsAddr=&quot;:9001&quot; &gt; out.log &amp; 3. Nginx 配置1234567891011121314server &#123; listen 80; root /usr/share/nginx/html; index index.html index.htm; server_name *.dev.applehater.cn;# 泛域名解析 location / &#123; proxy_pass http://localhost:9000; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $http_host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; 4. 客户端配置创建文件夹 ngrok 放进ngrok进去 创建启动脚本 start.sh1./ngrok -config ngrok.cfg start localhost 创建配置文件 ngrok.cfg1234567server_addr: &quot;dev.applehater.cn:4443&quot;tunnels: localhost: hostname: &quot;zohar.dev.applehater.cn&quot; #定义子子域名 proto: http: 127.0.0.1:8081 #映射端口，不加ip默认本机 https: 1127.0.0.1:443 赋予可执行权限1chmod a+x ngrok 运行1./start.sh 在开发调试基于 Oauth 的接口（微信，微博等）非常有用。 使用 docker 运行 ngrok把dev.applehater.cn改成你需要的域名 编译ngrok123456docker run -idt --name ngrok-server \\-v /opt/ngrok:/myfiles \\-p 9000:80 \\-p 9001:443 \\-p 4443:4443 \\-e DOMAIN=&apos;dev.applehater.cn&apos; hteen/ngrok /bin/sh /server.sh 运行ngrok12docker run --rm -it -e DOMAIN=&quot;dev.applehater.cn&quot; \\-v /opt/ngrok:/myfiles hteen/ngrok /bin/sh /build.sh","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zh-h.github.io/categories/Linux/"},{"name":"ngrok","slug":"Linux/ngrok","permalink":"https://zh-h.github.io/categories/Linux/ngrok/"}],"tags":[]},{"title":"Docker &amp; Spring Boot 实践","slug":"89","date":"2016-11-23T06:50:00.000Z","updated":"2019-10-26T21:49:24.160Z","comments":true,"path":"2016/11/23/89/","link":"","permalink":"https://zh-h.github.io/2016/11/23/89/","excerpt":"","text":"独立的日志服务 ELK 技术栈// TODO Maven Plugin使用开源的 Maven 自动打包 jar 构建镜像12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;appassembler-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.10&lt;/version&gt; &lt;configuration&gt; &lt;!-- 生成linux, windows两种平台的执行脚本 --&gt; &lt;platforms&gt; &lt;platform&gt;windows&lt;/platform&gt; &lt;platform&gt;unix&lt;/platform&gt; &lt;/platforms&gt; &lt;!-- 根目录 --&gt; &lt;assembleDirectory&gt;$&#123;project.build.directory&#125;/deploy&lt;/assembleDirectory&gt; &lt;!-- 打包的jar，以及maven依赖的jar放到这个目录里面 --&gt; &lt;repositoryName&gt;lib&lt;/repositoryName&gt; &lt;!-- 可执行脚本的目录 --&gt; &lt;binFolder&gt;bin&lt;/binFolder&gt; &lt;!-- 配置文件的目标目录 --&gt; &lt;configurationDirectory&gt;conf&lt;/configurationDirectory&gt; &lt;!-- 拷贝配置文件到上面的目录中 --&gt; &lt;copyConfigurationDirectory&gt;true&lt;/copyConfigurationDirectory&gt; &lt;!-- 从哪里拷贝配置文件 (默认src/main/config) --&gt; &lt;!--&lt;configurationSourceDirectory&gt;src/main/resources&lt;/configurationSourceDirectory&gt;--&gt; &lt;!-- lib目录中jar的存放规则，默认是$&#123;groupId&#125;/$&#123;artifactId&#125;的目录格式，flat表示直接把jar放到lib目录 --&gt; &lt;repositoryLayout&gt;flat&lt;/repositoryLayout&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;logsDirectory&gt;logs&lt;/logsDirectory&gt; &lt;tempDirectory&gt;tmp&lt;/tempDirectory&gt; &lt;!--生成后台启动服务--&gt; &lt;daemons&gt; &lt;daemon&gt; &lt;id&gt;demo-server&lt;/id&gt; &lt;mainClass&gt;&lt;/mainClass&gt; &lt;platforms&gt; &lt;platform&gt;jsw&lt;/platform&gt; &lt;/platforms&gt; &lt;generatorConfigurations&gt; &lt;generatorConfiguration&gt; &lt;generator&gt;jsw&lt;/generator&gt; &lt;includes&gt; &lt;include&gt;linux-x86-32&lt;/include&gt; &lt;include&gt;linux-x86-64&lt;/include&gt; &lt;include&gt;windows-x86-32&lt;/include&gt; &lt;include&gt;windows-x86-64&lt;/include&gt; &lt;/includes&gt; &lt;configuration&gt; &lt;property&gt; &lt;name&gt;configuration.directory.in.classpath.first&lt;/name&gt; &lt;value&gt;conf&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;wrapper.ping.timeout&lt;/name&gt; &lt;value&gt;120&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;set.default.REPO_DIR&lt;/name&gt; &lt;value&gt;lib&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;wrapper.logfile&lt;/name&gt; &lt;value&gt;logs/wrapper.log&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; &lt;/generatorConfiguration&gt; &lt;/generatorConfigurations&gt; &lt;jvmSettings&gt; &lt;!-- jvm参数 --&gt; &lt;systemProperties&gt; &lt;systemProperty&gt;com.sun.management.jmxremote&lt;/systemProperty&gt; &lt;systemProperty&gt;com.sun.management.jmxremote.port=1984&lt;/systemProperty&gt; &lt;systemProperty&gt;com.sun.management.jmxremote.authenticate=false&lt;/systemProperty&gt; &lt;systemProperty&gt;com.sun.management.jmxremote.ssl=false&lt;/systemProperty&gt; &lt;/systemProperties&gt; &lt;/jvmSettings&gt; &lt;/daemon&gt; &lt;/daemons&gt; &lt;programs&gt; &lt;program&gt; &lt;id&gt;auto-server&lt;/id&gt; &lt;!-- 启动类 --&gt; &lt;mainClass&gt;&lt;/mainClass&gt; &lt;jvmSettings&gt; &lt;extraArguments&gt; &lt;extraArgument&gt;-server&lt;/extraArgument&gt; &lt;extraArgument&gt;-Xmx2G&lt;/extraArgument&gt; &lt;extraArgument&gt;-Xms2G&lt;/extraArgument&gt; &lt;/extraArguments&gt; &lt;/jvmSettings&gt; &lt;/program&gt; &lt;/programs&gt; &lt;/configuration&gt; &lt;/plugin&gt; Docker BuildDockerfile123456FROM java:8VOLUME /tmpADD auto-system-server.jar app.jarRUN sh -c &apos;touch /app.jar&apos;ENV JAVA_OPTS=&quot;&quot;ENTRYPOINT [ &quot;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app.jar&quot; ] build1docker build -t zonghua/docker-demo . run1docker run -d -p 8080:8080 --name auto-system zonghua/docker-demo","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zh-h.github.io/categories/Linux/"},{"name":"docker","slug":"Linux/docker","permalink":"https://zh-h.github.io/categories/Linux/docker/"}],"tags":[]},{"title":"JFinal 使用 apidoc 创建文档","slug":"88","date":"2016-11-20T07:56:40.000Z","updated":"2019-10-26T21:49:24.159Z","comments":true,"path":"2016/11/20/88/","link":"","permalink":"https://zh-h.github.io/2016/11/20/88/","excerpt":"","text":"项目使用 JFinal 的时候没法使用 Swagger 去自动生成文档。 依靠注释配置的文档工具 apidoc 就非常适合 Java 方法注释12345678910/** * @api &#123;get&#125; /user/:id Request User information * @apiName GetUser * @apiGroup User * * @apiParam &#123;Number&#125; id Users unique ID. * * @apiSuccess &#123;String&#125; firstname Firstname of the User. * @apiSuccess &#123;String&#125; lastname Lastname of the User. */ 创建文档1apidoc 生成 官方文档","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"}],"tags":[]},{"title":"Java 中的参数和引用","slug":"87","date":"2016-11-19T21:14:58.000Z","updated":"2019-10-26T21:49:24.159Z","comments":true,"path":"2016/11/20/87/","link":"","permalink":"https://zh-h.github.io/2016/11/20/87/","excerpt":"","text":"对于原始数据类型，也就是int、 long、char之类的类型，是传值的，如果你在方法中修改了值，方法调用结束后，那个变量的值没用改变。 对于对象类型，也就是Object的子类，如果你在方法中修改了它的成员的值，那个修改是生效的，方法调用结束后，它的成员是新的值，但是如果你把它指向一个其它的对象，方法调用结束后，原来对它的引用并没用指向新的对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class ReferenceValue &#123; public static void main(String[] args) &#123; StringBuffer a = new StringBuffer(&quot;I am kitty&quot;); System.out.println(a); changeBufferValue(a); System.out.println(a); reRefer(a); System.out.println(a); Cat kitty = new Cat(); System.out.println(kitty); changeReference(kitty); System.out.println(kitty); reRefer(kitty); System.out.println(kitty); &#125; public static void changeBufferValue(StringBuffer sb) &#123; sb.append(&quot;, Hello&quot;); &#125; public static void reRefer(StringBuffer sb) &#123; sb = new StringBuffer(&quot;6666&quot;); &#125; public static void changeReference(Cat cat) &#123; cat.color = Color.PINK; &#125; public static void reRefer(Cat cat) &#123; cat = new Cat(); cat.name = &quot;Tom&quot;; cat.color = Color.BLACK; &#125; static class Cat &#123; Color color = Color.YELLOW; String name = &quot;Kitty&quot;; @Override public String toString() &#123; return this.name + &quot; &quot; + this.color; &#125; &#125;&#125; 输出123456I am kittyI am kitty, HelloI am kitty, HelloKitty java.awt.Color[r=255,g=255,b=0]Kitty java.awt.Color[r=255,g=175,b=175]Kitty java.awt.Color[r=255,g=175,b=175]","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"}],"tags":[]},{"title":"Javascript 周索引","slug":"86","date":"2016-11-05T02:34:00.000Z","updated":"2019-10-26T21:49:24.159Z","comments":true,"path":"2016/11/05/86/","link":"","permalink":"https://zh-h.github.io/2016/11/05/86/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839function getYearWeekIndex(now)&#123; years = now.getYear(); if (years &lt; 1000)&#123; years += 1900 &#125; var days = new Array(12); days[0] = 31; days[2] = 31; days[3] = 30; days[4] = 31; days[5] = 30; days[6] = 31; days[7] = 31; days[8] = 30; days[9] = 31; days[10] = 30; days[11] = 31; //判断是否为闰年，针对2月的天数进行计算 if (Math.round(now.getYear() / 4) == now.getYear() / 4) &#123; days[1] = 29; &#125; else &#123; days[1] = 28; &#125; var totaldays = 0; if (now.getMonth() == 0) &#123; totalDays = totalDays + now.getDate(); &#125; else &#123; var curMonth = now.getMonth(); for (var count = 1; count &lt;= curMonth; count++) &#123; totalDays = totalDays + days[count - 1]; &#125; totalDays = totalDays + now.getDate(); &#125; //得到第几周 var week = Math.round(totalDays / 7); return week;&#125;; 调了好多次，终于算得和接口得数据一样了","categories":[{"name":"默认分类","slug":"默认分类","permalink":"https://zh-h.github.io/categories/默认分类/"},{"name":"数据结构与算法","slug":"默认分类/数据结构与算法","permalink":"https://zh-h.github.io/categories/默认分类/数据结构与算法/"},{"name":"计算机基础","slug":"默认分类/数据结构与算法/计算机基础","permalink":"https://zh-h.github.io/categories/默认分类/数据结构与算法/计算机基础/"}],"tags":[]},{"title":"微信 AirKiss 技术","slug":"83","date":"2016-10-14T06:34:00.000Z","updated":"2019-10-26T21:49:24.159Z","comments":true,"path":"2016/10/14/83/","link":"","permalink":"https://zh-h.github.io/2016/10/14/83/","excerpt":"","text":"Airkiss顾名思义是飞吻的意思，即手机发送的SSID和密码经过路由转发出去，被目前wifi设备所检测并截获到。无线网络协议一般场景都规定station只能和AP通信，而不能station和station通信（这种场景叫做AD-Hoc点对点）。接下来我们分析SSID和pwd怎么利用Length进行编码的过程。 通信协议1. 物理层发送4个字节的前导码序列，{1,2,3,4}。即发送4个数据帧，帧长度分别是1,2,3,4.其要解决两个问题： 空中充满无线信号，通过前导码来识别出符合airkiss协议的数据包的开始。 数据包的数据是经过加密的，发送方的数据帧的有效数据的长度是1，经过编码后的长度会发送变化。假设加密后的长度为N，那接收方接收到的数据长度是N。以后所有的数据帧接收的长度是M时，那发送方真正的数据长度是M-N+1。 Airkiss规定数据的长度使用9个bit进行编码。 2. 数据链路层数据链路层的包括控制字段和数据字段。 Magic为4个数据帧，两个帧的两个9bit记录将要发送的数据（PWD+Ramdon+SSID）的长度；两个帧的两个9bit记录SSID的CRC校验值。路由器的SSID是会被路由器广播出来的，例如我们手机wifi扫描到路由器的名称就是SSID。因此wifi设备也能得到路由器的SSID，其只要计算目前所能获取到的SSID的CRC值跟MAGIC的SSID CRC值一样，那之后的SSID数据就不用接收了，这样能够提高配置上网速度。Magic很重要，因此发送5遍。 PrefixCode为4个数据帧，两个帧的两个9bit记录PWD的数据长度，另外两个帧的两个9bit记录PWD长度的CRC校验值。Magic中发送的长度是所有数据的长度，包括密码PWD、随机数（wifi配置成功后要回复该随机数作为回复）和SSID。而这里是PWD的长度，用于对接收到的数据进行分段。 一个序列包括一个序列索引和一个序列数据。协议规定将有效数据以4个字节进行划分，不够补0。如我家路由的PWD是8313huang，那其会分为3个序列，分别是“8313”、“huan”“g\\0\\0\\0”进行发送。Sequence header包括索引值和CRC值，而Data field就是4个数据帧，包含要发送的数据，如“8313”等。 4）如何区分Magic、Prefix、Sequence和Data，是由9bit的最高几个bit来区分的。例如最高bit为1时表示是Data，其他是控制字段。 3. 应用层应用层即是手机配置上网APP要发送的数据，包括三部分的数据。分别是： PWD。其先被发送是因为其是最重要的，而SSID已经在MAGIC字段中所确认。 1个字节的随机数。wifi配置成功后要发送以该随机数为内容的UDP广播包作为回复，APP收到后即认为wifi设备已经成功联网。 SSID。 UE响应微信服务器消息应用服务器接入 http://iot.weixin.qq.com/wiki/static/image/11_1_c-12.png 绑定消息 消息处理用户通过扫描设备二维码绑定设备后，微信会推送设备绑定事件给第三方。用户通过取消关注设备公众号解绑设备后，微信会推送设备解绑事件给第三方。微信用户绑定设备后，设备会通过微信给第三方发送消息。 123456789101112&lt;xml&gt; &lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt; &lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt; &lt;CreateTime&gt;%u&lt;/CreateTime&gt; &lt;MsgType&gt;&lt;![CDATA[%s]]&gt;&lt;/MsgType&gt; &lt;DeviceType&gt;&lt;![CDATA[%s]]&gt;&lt;/DeviceType&gt; &lt;DeviceID&gt;&lt;![CDATA[%s]]&gt;&lt;/DeviceID&gt; &lt;Content&gt;&lt;![CDATA[%s]]&gt;&lt;/Content&gt; &lt;SessionID&gt;%lu&lt;/SessionID&gt; &lt;MsgID&gt;%lu&lt;/MsgID&gt; &lt;OpenID&gt;&lt;![CDATA[%s]]&gt;&lt;/OpenID&gt;&lt;/xml&gt; 应用服务器接收消息进行机智云平台的绑定123456789101112131415161718192021222324252627 @RequestMapping(value = &quot;/api&quot;, method = RequestMethod.POST) @ResponseBody public String dispose(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; /* 消息的接收、响应、处理 */ logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 接受请求&quot;); // 调用核心业务类接收消息、处理消息 return messageHandler.processRequest(request); &#125;public void handle(String xml) &#123; logger.info(&quot; --------&gt; 开始处理设备事件&quot;); WxEventDeviceBind device = (WxEventDeviceBind) XMLUtil.getWxMsg(WxEventDeviceBind.class, xml); logger.info(&quot; --------&gt; 解析成功：\\n&#123;&#125;\\n&quot;, device); switch (device.getEvent()) &#123; case &quot;bind&quot;: bindDevice(device); break; case &quot;unbind&quot;: unbindDevice(device); break; default: logger.info(&quot; --------&gt; 发现事件：\\n&#123;&#125;\\n&quot;, device); &#125; &#125;","categories":[{"name":"IoT","slug":"IoT","permalink":"https://zh-h.github.io/categories/IoT/"},{"name":"微信","slug":"IoT/微信","permalink":"https://zh-h.github.io/categories/IoT/微信/"}],"tags":[]},{"title":"Elasticsearch 笔记","slug":"80","date":"2016-09-29T21:23:21.000Z","updated":"2019-10-26T21:49:24.159Z","comments":true,"path":"2016/09/30/80/","link":"","permalink":"https://zh-h.github.io/2016/09/30/80/","excerpt":"","text":"1// TODO 准备假期好好学习一下","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"}],"tags":[]},{"title":"Jetty 路径差异 Tomcat","slug":"78","date":"2016-09-26T02:27:00.000Z","updated":"2019-10-26T21:49:24.159Z","comments":true,"path":"2016/09/26/78/","link":"","permalink":"https://zh-h.github.io/2016/09/26/78/","excerpt":"","text":"之前在 Eclipse 上使用 Tomcat 运行使用了 Spring Web 的应用一直正常，但是打包部署到 Jetty 运行就出现 404 的问题，查看日志 Spring 容器启动也一切正常，找不到原因。 换而使用 Maven Jetty Plugin 运行的时候也同样出现了问题。 12345@RequestMapping(&quot;/&quot;)public String index(@RequestParam(defaultValue = &quot;1&quot;, value = &quot;p&quot;) int p, Model model) &#123; return &quot;/home/index&quot;; // 在 Jetty 中运行会有多余的前置路径分隔符&#125; 404 显示找不到 webapp/WEB-INF/jsp//home/index.jsp 多了一层路径 查看 Servlet API Returns a RequestDispatcher object that acts as a wrapper for the resource located at the given path. A RequestDispatcher object can be used to forward a request to the resource or to include the resource in a response. The resource can be dynamic or static.The pathname specified may be relative, although it cannot extend outside the current servlet context. If the path begins with a “/“ it is interpreted as relative to the current context root. This method returns null if the servlet container cannot return a RequestDispatcher.The difference between this method and ServletContext.getRequestDispatcher(java.lang.String) is that this method can take a relative path. Spring Web 测试源码 spring-web/src/test/java/org/springframework/mock/web/test/MockServletContext.java 会在路径前面判断加上分隔符123456789101112131415161718/** * Build a full resource location for the given path, prepending the resource * base path of this &#123;@code MockServletContext&#125;. * @param path the path as specified * @return the full resource path */ protected String getResourceLocation(String path) &#123; if (!path.startsWith(&quot;/&quot;)) &#123; path = &quot;/&quot; + path; &#125; return this.resourceBasePath + path; &#125; public RequestDispatcher getRequestDispatcher(String path) &#123; Assert.isTrue(path.startsWith(&quot;/&quot;), () -&gt; &quot;RequestDispatcher path [&quot; + path + &quot;] at ServletContext level must start with &apos;/&apos;&quot;); return new MockRequestDispatcher(path); &#125; Jetty 相对 Tomcat 两种写法有差异，所以导致使用 Spring MVC 运行的时候会叠加上多余的路径分隔符","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"}],"tags":[]},{"title":"Java 的正则工具使用","slug":"77","date":"2016-09-24T03:03:00.000Z","updated":"2019-10-26T21:49:24.159Z","comments":true,"path":"2016/09/24/77/","link":"","permalink":"https://zh-h.github.io/2016/09/24/77/","excerpt":"","text":"先来欣赏一下符合 rfc5322 标准的 Email 格式正则1(?:[a-z0-9!#$%&amp;&apos;*+/=?^_`&#123;|&#125;~-]+(?:\\.[a-z0-9!#$%&amp;&apos;*+/=?^_`&#123;|&#125;~-]+)*|&quot;(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*&quot;)@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\]) Matcher检查用户名和密码，只能由数字和字母构成，长度4到8位。123456789101112131415public class CheckAuthInfo &#123; public static void main(String[] args) &#123; D.d(checkAuthInfo(&quot;fWlj23&quot;)); D.d(checkAuthInfo(&quot;)*&amp;^^*sdhf232&quot;)); D.d(checkAuthInfo(&quot;哈哈哈哈&quot;)); &#125; public static boolean checkAuthInfo(String field)&#123; // 字符串里的 \\ 要转义，包含字符例如 （ 的时候要 \\\\( 转义使用 Pattern userInfoPattern = Pattern.compile(&quot;^[\\\\w|\\\\d]&#123;4,8&#125;$&quot;); Matcher matcher = userInfoPattern.matcher(field); // 如果没有找到而使用 group 方法会导致异常，group 按照 （） 分组捕获 return matcher.find(); &#125;&#125; 输出123truefalsefalse Java regex API 用的东西杂了，就会经常把符号弄混，之前手写代码竟然写成了 ^(\\w|\\d)[4,8]$ 错得很是尴尬 晕乎乎的 PHP 是这样写的123456$regex = &apos;/^http:\\/\\/([\\w.]+)\\/([\\w]+)\\/([\\w]+)\\.html$/i&apos;; // / 符号要反转义$str = &apos;http://applehater.cn&apos;;$matches = array();if(preg_match($regex, $str, $matches))&#123; var_dump($matches);&#125; 纠缠到 Python 是这样的123// 用 r 修饰的字符串直接就是正则对象，也不用像 Java 一样转义m = re.match(r&quot;(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$)&quot;, &apos;admin@applehater.cn&apos;)print m.group() // 如果没有找到就返回 None ， Java 这样用会抛出异常的 Python re.regex.pattern API","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"},{"name":"正则","slug":"Java/正则","permalink":"https://zh-h.github.io/categories/Java/正则/"}],"tags":[]},{"title":"BIO AIO NIO","slug":"76","date":"2016-09-23T06:30:00.000Z","updated":"2019-10-26T21:49:24.159Z","comments":true,"path":"2016/09/23/76/","link":"","permalink":"https://zh-h.github.io/2016/09/23/76/","excerpt":"","text":"Java API补一下 Java IO 的用法 NIO12345678910111213141516171819RandomAccessFile aFile = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);FileChannel inChannel = aFile.getChannel();//create buffer with capacity of 48 bytesByteBuffer buf = ByteBuffer.allocate(48);int bytesRead = inChannel.read(buf); //read into buffer.while (bytesRead != -1) &#123; buf.flip(); //make buffer ready for read while(buf.hasRemaining())&#123; System.out.print((char) buf.get()); // read 1 byte at a time &#125; buf.clear(); //make buffer ready for writing bytesRead = inChannel.read(buf);&#125;aFile.close(); BIO123456789ByteArrayOutputStream buffer = new ByteArrayOutputStream();InputStream inputStream = req.getInputStream();int nRead;byte[] data = new byte[1024];while ((nRead = inputStream.read(data, 0, data.length)) != -1) &#123; buffer.write(data, 0, nRead);&#125;buffer.flush();byte[] byteArray = buffer.toByteArray(); byte 是八位整数，范围 -127~127short 2byteint 4bytelong 8byte byte 也是整型，非浮点数都是整型","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"}],"tags":[]},{"title":"单例模式有七种 QAQ","slug":"75","date":"2016-09-20T04:09:00.000Z","updated":"2019-10-26T21:49:24.159Z","comments":true,"path":"2016/09/20/75/","link":"","permalink":"https://zh-h.github.io/2016/09/20/75/","excerpt":"","text":"为了能做准确描述实例，下列类都是单身汪 1. 懒汉式12345678910public class SingleDog &#123; private static SingleDog instance; private SingleDog ()&#123;&#125; public static SingleDog getInstance() &#123; if (instance == null) &#123; instance = new SingleDog(); &#125; return instance; &#125; &#125; 2. 懒汉式（同步方法）1234567891011public class SingleDog &#123; private static SingleDog instance; private SingleDog() &#123; &#125; public static synchronized SingleDog getInstance() &#123; if (instance == null) &#123; instance = new SingleDog(); &#125; return instance; &#125;&#125; 3. 饿汉式（静态成员）1234567public class SingleDog &#123; private static SingleDog instance = new SingleDog(); private SingleDog ()&#123;&#125; public static SingleDog getInstance() &#123; return instance; &#125; &#125; 4. 饿汉式（静态代码块）12345678910public class SingleDog&#123; private static SingleDog instance = null; static&#123; instance = new SingleDog(); &#125; private SingleDog()&#123;&#125; public static SingleDog getInstance()&#123; return instance; &#125;&#125; 5. 饿汉式（静态内部类）123456789101112public class SingleDog &#123; private static class SingleDogHolder &#123; private static final SingleDog INSTANCE = new SingleDog(); &#125; private SingleDog() &#123; &#125; public static final SingleDog getInstance() &#123; return SingleDogHolder.INSTANCE; &#125;&#125; 6. 枚举123456public enum SingleDog&#123; INSTANCE; public void metting(Girl she)&#123; // TODO &#125;&#125; 7. 懒汉式（双重检查锁 ）123456789101112131415161718192021public class SingleDog &#123; private volatile static SingleDog singleDog = null; private SingleDog() &#123; &#125; public static SingleDog getInstance() &#123; if (singleDog == null) &#123; // 使用 volatile 保证了线程可见性，所以不用锁 synchronized (SingleDog.class) &#123; // 锁定不给其他变量操作 SingleDog temp = singleDog; synchronized (SingleDog.class) &#123; // 保证读写有序 if (temp == null) &#123; singleDog = new SingleDog(); &#125; &#125; singleDog = temp; &#125; &#125; return singleDog; &#125;&#125; volatile 变量写后读，保障读取瞬时都是正确非空的判断。","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"}],"tags":[]},{"title":"Create a global .gitignore","slug":"74","date":"2016-09-17T06:27:02.000Z","updated":"2019-10-26T21:49:24.159Z","comments":true,"path":"2016/09/17/74/","link":"","permalink":"https://zh-h.github.io/2016/09/17/74/","excerpt":"","text":"Create a global .gitignore","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zh-h.github.io/categories/Linux/"},{"name":"git","slug":"Linux/git","permalink":"https://zh-h.github.io/categories/Linux/git/"}],"tags":[]},{"title":"提高基于 Spring 项目的开发速度——热替换","slug":"73","date":"2016-09-15T22:01:06.000Z","updated":"2019-10-26T21:49:24.158Z","comments":true,"path":"2016/09/16/73/","link":"","permalink":"https://zh-h.github.io/2016/09/16/73/","excerpt":"","text":"1. HotSpot只能更改方法体，或者更改成员属性的参数 1474004609007 Debug 更改代码，然后重新编译类就可以替换 2. Spring-Loaded对 方法 | 字段 | 构造器 进行 添加 | 修改 | 删除，类型 | 方法 | 字段 | 构造器 上的注解也允许修改 1474004692232 但是因为 Spring 的 IOC 原理，如果是注解的类还是需要重启容器才能起效 1-javaagent:C:\\Tools\\springloaded-1.2.5.RELEASE.jar -noverify 需要配置下载的包，然后在使用 jetty 启动的时候指定参数 1474003592881 IDEA 使用 Ctrl+Shift+F9 编译类，如果增加移除类就需要编译整个包","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"}],"tags":[]},{"title":"提高基于 Spring 项目的开发速度——热部署","slug":"72","date":"2016-09-15T22:00:00.000Z","updated":"2019-10-26T21:49:24.158Z","comments":true,"path":"2016/09/16/72/","link":"","permalink":"https://zh-h.github.io/2016/09/16/72/","excerpt":"","text":"1. 使用 jetty 插件12345678910111213141516&lt;plugin&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;9.2.12.v20150709&lt;/version&gt; &lt;configuration&gt; &lt;stopKey&gt;stop&lt;/stopKey&gt; &lt;stopPort&gt;4502&lt;/stopPort&gt; &lt;webApp&gt; &lt;contextPath&gt;/&lt;/contextPath&gt; &lt;/webApp&gt; &lt;httpConnector&gt; &lt;port&gt;8080&lt;/port&gt; &lt;/httpConnector&gt; &lt;reload&gt;manual&lt;/reload&gt; &lt;/configuration&gt; &lt;/plugin&gt;","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"}],"tags":[]},{"title":"解决虚拟机桥接网络无法访问 Django 服务","slug":"71","date":"2016-09-12T04:30:00.000Z","updated":"2019-10-26T21:49:24.158Z","comments":true,"path":"2016/09/12/71/","link":"","permalink":"https://zh-h.github.io/2016/09/12/71/","excerpt":"","text":"折腾了好久，试过更改主机 Windows 上的防火墙，也试过更新宿主机 Ubuntu 上的防火墙ufw都没有起效。只好用 Nginx 方向代理访问。 后来调试一个 socket 程序的时候才突然想到，是监听 ip 的问题，默认只监听127.0.0.1:8000所以要把启动参数修改一下即可。 1./manage.py runserver 0.0.0.0:8000 这样表示监听全部 ip 访问。","categories":[{"name":"Django","slug":"Django","permalink":"https://zh-h.github.io/categories/Django/"}],"tags":[]},{"title":"并发与并行","slug":"70","date":"2016-09-10T05:26:00.000Z","updated":"2019-10-26T21:49:24.158Z","comments":true,"path":"2016/09/10/70/","link":"","permalink":"https://zh-h.github.io/2016/09/10/70/","excerpt":"","text":"前者是逻辑上的同时发生（simultaneous），而后者是物理上的同时发生。 并发性(concurrency)，又称共行性，是指能处理多个同时性活动的能力，并发事件之间不一定要同一时刻发生。例如：进程B的开始时间是在进程A的开始时间与结束时间之间，我们就说A和B是并发的。 1234567891011121314 +----------------------+ | +--------------+ | | | | |+------------&gt; | Task A | | | | | | | +--------------+ | | | | +--------------+ | | | | |+------------&gt; | Task B | | | | | | | +--------------+ | +----------------------+ Core 并行(parallelism)是并发的真子集指同时发生的两个并发事件，具有并发的含义，而并发则不一定并行。例如：同一时间两个进程运行在不同的机器上或者同一个机器不同的核心上，超级计算机操作系统的设计就是非常注重并行，因为要把处理任务分成千上万的的进程在成千上万的处理器上执行。 12345678910111213141516 +------------------+ | +--------------+ | | | | | +----&gt; | | Task A | | | | | | | | | +--------------+ | | +------------------++------&gt; Core 1 | +------------------+ | | +--------------+ | | | | | | +-----^+ | Task B | | | | | | | +--------------+ | +------------------+ Core 2","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://zh-h.github.io/categories/计算机基础/"}],"tags":[]},{"title":"棘手的Lxml安装","slug":"68","date":"2016-09-07T05:57:00.000Z","updated":"2019-10-26T21:49:24.158Z","comments":true,"path":"2016/09/07/68/","link":"","permalink":"https://zh-h.github.io/2016/09/07/68/","excerpt":"","text":"使用pip各种方法安装不上，只好使用apt去安装。 需要解决依赖 apt-get install libxml2-dev libxslt-dev python2.7-dev```1234然后安装`apt`里面最新版本`3.5.0`的Lxml （pip里面的是3.6.X不需要用到）```sudo apt-get install python-lxml","categories":[{"name":"Python","slug":"Python","permalink":"https://zh-h.github.io/categories/Python/"}],"tags":[]},{"title":"在if处填写什么代码，可以使得输出结果为：AB","slug":"67","date":"2016-09-03T07:56:00.000Z","updated":"2019-10-26T21:49:24.158Z","comments":true,"path":"2016/09/03/67/","link":"","permalink":"https://zh-h.github.io/2016/09/03/67/","excerpt":"","text":"遇到一道很奇葩的问题 1. 下面代码中，在if处填写什么代码，可以使得输出结果为：AB问题123456789public class Doge&#123; public static void main(String[] args) &#123; if( /* */)&#123; System.out.print(&apos;A&apos;); &#125;else&#123; System.out.print(&apos;B&apos;); &#125; &#125;&#125; 输出1AB 歪解123456789101112public class Doge&#123; public static void main(String[] args) &#123; if( 1==1)&#123; System.out.print(&apos;A&apos;); System.out.print(&apos;B&apos;); &#125;else if (2==2)&#123; System.out.print(&apos;A&apos;); &#125;else&#123; System.out.print(&apos;B&apos;); &#125; &#125;&#125; 正解123456789public class Doge&#123; public static void main(String[] args) &#123; if( System.out.printf(&quot;A&quot;) == null)&#123; System.out.print(&apos;A&apos;); &#125;else&#123; System.out.print(&apos;B&apos;); &#125; &#125;&#125; 解析查看源码 XD12345678910111213141516171819202122232425/***使用了格式化输出方法，向控制台输出字符A后，返回了一个PrintStream对象*PrintStream对象不为空，所以跳转到否的语句，输出B*/public PrintStream printf(Locale l, String format, Object ... args) &#123; return format(l, format, args);&#125;public PrintStream format(String format, Object ... args) &#123; try &#123; //同步代码，保证多个线程输出的时候只有一段方法块执行 synchronized (this) &#123; ensureOpen(); if ((formatter == null) || (formatter.locale() != Locale.getDefault())) formatter = new Formatter((Appendable) this); formatter.format(Locale.getDefault(), format, args); &#125; &#125; catch (InterruptedIOException x) &#123; Thread.currentThread().interrupt(); &#125; catch (IOException x) &#123; trouble = true; &#125; return this;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"},{"name":"题","slug":"Java/题","permalink":"https://zh-h.github.io/categories/Java/题/"}],"tags":[]},{"title":"Vim 操作集合","slug":"66","date":"2016-08-30T00:43:00.000Z","updated":"2019-10-26T21:49:24.158Z","comments":true,"path":"2016/08/30/66/","link":"","permalink":"https://zh-h.github.io/2016/08/30/66/","excerpt":"","text":"打开文件vim 打开 Vim 欢迎页面vim filename 打开文件，文件名不存在是创建文件vim foldername 打开文件夹:open file 当前窗口打开文件:split file 新窗口打开文件:bn 下一个文件:bp 上一个文件 模式切换正常模式（按Esc或Ctrl+[进入） 左下角显示文件名或为空插入模式（按i键进入） 左下角显示–INSERT–可视模式（按v进入） 左下角显示–VISUAL– 插入命令i 在当前位置生前插入I 在当前行首插入a 在当前位置后插入A 在当前行尾插入o 在当前行之后插入一行O 在当前行之前插入一行 查找命令/text 查找text，按n健查找下一个，按N健查找前一个。?text 查找text，反向查找，按n健查找下一个，按N健查找前一个。光标移动到该词上，按或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索vim中有一些特殊字符转义 .[]^%/?~$ 替换命令s/old/new/ old替换new，替换当前行的第一个匹配s/old/new/g old替换new，替换当前行的所有匹配%s/old/new/ old替换new，替换所有行的第一个匹配%s/old/new/g old替换new，替换整个文件的所有匹配 移动命令h 左移一个字符l 右移一个字符k 上移一个字符j 下移一个字符以上命令可以与数字组合，如先按2再按j就是向下移动两个字符 w 向前移动一个单词,光标停留在行首，如果已到行尾，则转至下一行行首。b 向后移动一个单词e 同w，光标停在单词尾部ge 同b，光标停在单词尾部gg 移动到文件头G 移动到文件尾^ 移动到本行第一个非空白字符上0 移动到本行第一个字符上 :200 跳转到行数 Ctrl + e 向下滚动一行Ctrl + y 向上滚动一行Ctrl + d 向下滚动半屏Ctrl + u 向上滚动半屏Ctrl + f 向下滚动一屏Ctrl + b 向上滚动一屏 撤销操作u 撤销（Undo）U 撤销对整行的操作Ctrl + r 重做，相当于 Windows 里用的 Ctrl Y 删除操作x 删除光标后字符3x 删除当前光标开始向后三个字符X 删除当前字符的前一个字符dd 删除当前行10d 删除当前行开始的10行。D 删除当前字符至行尾:1,10d 删除1-10行 复制粘贴剪切进入可视模式，hljk移动光标，选中部分高亮y 复制高亮部分d 剪切 普通模式yy 拷贝当前行nyy 拷贝当前后开始的n行p 在当前光标后粘贴P 在当前行前粘贴ddp 交换当前行和其下一行xp 交换当前字符和其后一个字符 全局命令:wq 保存并退出:q! 强制退出并忽略所有更改:e! 放弃所有修改，并打开原来文件Ctrl+ww 移动到下一个窗口Ctrl+wj 移动到下方的窗口Ctrl+wk 移动到上方的窗口:close 最后一个窗口不能使用此命令 注释命令1,10 s/^/#/g 注释第1-10行1,10 s/^#//g 解除1-10行的注释 执行:!command 执行shell命令 其他:help xxx 显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。:help ‘number’ Vim选项的帮助用单引号括起:help 特殊键的帮助用&lt;&gt;扩起 Vim tutor随时随地学习1vimtutor vim","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zh-h.github.io/categories/Linux/"},{"name":"vim","slug":"Linux/vim","permalink":"https://zh-h.github.io/categories/Linux/vim/"}],"tags":[]},{"title":"二叉查找树 (BST)","slug":"60","date":"2016-08-25T04:28:00.000Z","updated":"2019-10-26T21:49:24.158Z","comments":true,"path":"2016/08/25/60/","link":"","permalink":"https://zh-h.github.io/2016/08/25/60/","excerpt":"","text":"定义任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；任意节点的左、右子树也分别为二叉查找树；没有键值相等的节点。 特点插入删除查找的平均复杂度都是O(log n)，当节点有序的时候退化成链表O(n)复杂度（树的全部结点都只有左/右子树） 类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105public class BinaryTree implements ITree &#123; Node root; public static void main(String[] args) &#123; BinaryTree binaryTree = new BinaryTree(); binaryTree.insert(4, 2); binaryTree.insert(3, 23423); binaryTree.insert(2, 234); binaryTree.display(binaryTree.root); &#125; public void display(Node node) &#123; if (node != null) &#123; System.out.println(node.id + &quot; &quot; + node.data); &#125; if (node.left != null) &#123; display(node.left); &#125; if (node.right != null) &#123; display(node.right); &#125; &#125; public void insert(int id, Object data) &#123; Node node = new Node(); node.id = id; node.data = data; insert(node); &#125; public void insert(Node node) &#123; if (root == null) &#123; root = node; return ; &#125; Node currentNode = root; while (true) &#123; if (node.id &lt; currentNode.id) &#123; currentNode = currentNode.left; if (currentNode == null) &#123; currentNode = node; &#125; &#125; else if (node.id &gt; currentNode.id) &#123; currentNode = currentNode.right; if (currentNode == null) &#123; currentNode = node; &#125; &#125; else &#123; currentNode = node; break; &#125; &#125; &#125; public Node max()&#123; Node currentNode; if(root!=null)&#123; currentNode = root; &#125;else&#123; return null; &#125; while(true)&#123; if(currentNode.right!=null)&#123; currentNode = currentNode.right; &#125;else&#123; return currentNode; &#125; &#125; &#125; public Node min()&#123; Node currentNode; if(root!=null)&#123; currentNode = root; &#125;else&#123; return null; &#125; while(true)&#123; if(currentNode.left!=null)&#123; currentNode = currentNode.left; &#125;else&#123; return currentNode; &#125; &#125; &#125; public Node find(int key) &#123; Node currentNode = root; while (currentNode.id != key) &#123; if (currentNode.id &gt; key) &#123; currentNode = currentNode.left; &#125; else if (currentNode.id &lt; key) &#123; currentNode = currentNode.right; &#125; if (currentNode == null) &#123; return null; &#125; &#125; return currentNode; &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zh-h.github.io/categories/数据结构与算法/"},{"name":"树","slug":"数据结构与算法/树","permalink":"https://zh-h.github.io/categories/数据结构与算法/树/"}],"tags":[]},{"title":"ASCii","slug":"58","date":"2016-08-18T03:10:25.000Z","updated":"2019-10-26T21:49:24.157Z","comments":true,"path":"2016/08/18/58/","link":"","permalink":"https://zh-h.github.io/2016/08/18/58/","excerpt":"","text":"ASCII值 控制字符 ASCII值 控制字符 ASCII值 控制字符 ASCII值 控制字符 0 NUT 32 (space) 64 @ 96 、 1 SOH 33 ! 65 A 97 a 2 STX 34 “ 66 B 98 b 3 ETX 35 # 67 C 99 c 4 EOT 36 $ 68 D 100 d 5 ENQ 37 % 69 E 101 e 6 ACK 38 &amp; 70 F 102 f 7 BEL 39 , 71 G 103 g 8 BS 40 ( 72 H 104 h 9 HT 41 ) 73 I 105 i 10 LF 42 * 74 J 106 j 11 VT 43 + 75 K 107 k 12 FF 44 , 76 L 108 l 13 CR 45 - 77 M 109 m 14 SO 46 . 78 N 110 n 15 SI 47 / 79 O 111 o 16 DLE 48 0 80 P 112 p 17 DCI 49 1 81 Q 113 q 18 DC2 50 2 82 R 114 r 19 DC3 51 3 83 S 115 s 20 DC4 52 4 84 T 116 t 21 NAK 53 5 85 U 117 u 22 SYN 54 6 86 V 118 v 23 TB 55 7 87 W 119 w 24 CAN 56 8 88 X 120 x 25 EM 57 9 89 Y 121 y 26 SUB 58 : 90 Z 122 z 27 ESC 59 ; 91 [ 123 { 28 FS 60 &lt; 92 / 124 | 29 GS 61 = 93 ] 125 } 30 RS 62 &gt; 94 ^ 126 ` 31 US 63 ? 95 _ 127 DEL 特殊字符解释 NUL空 VT 垂直制表 SYN 空转同步 STX 正文开始 CR 回车 CAN 作废 ETX 正文结束 SO 移位输出 EM 纸尽 EOY 传输结束 SI 移位输入 SUB 换置 ENQ 询问字符 DLE 空格 ESC 换码 ACK 承认 DC1 设备控制1 FS 文字分隔符 BEL 报警 DC2 设备控制2 GS 组分隔符 BS 退一格 DC3 设备控制3 RS 记录分隔符 HT 横向列表 DC4 设备控制4 US 单元分隔符 LF 换行 NAK 否定 DEL 删除","categories":[],"tags":[]},{"title":"运算符优先级","slug":"57","date":"2016-08-18T03:07:47.000Z","updated":"2019-10-26T21:49:24.157Z","comments":true,"path":"2016/08/18/57/","link":"","permalink":"https://zh-h.github.io/2016/08/18/57/","excerpt":"","text":"Java 运算符优先级运算符优先级postfixexpr++ expr–unary++expr –expr +expr -expr ~ !multiplicative / %additive+ -shift&lt;&lt; &gt;&gt; &gt;&gt;&gt;relational&lt; &gt; &lt;= &gt;= instanceofequality== !=bitwise AND&amp;bitwise exclusive OR^bitwise inclusive OR|logical AND&amp;&amp;logical OR||ternary? :assignment= += -= = /= %= &amp;= ^= |= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=","categories":[],"tags":[]},{"title":"watch 实时监控命令","slug":"56","date":"2016-08-18T00:46:00.000Z","updated":"2019-10-26T21:49:24.157Z","comments":true,"path":"2016/08/18/56/","link":"","permalink":"https://zh-h.github.io/2016/08/18/56/","excerpt":"","text":"某司面试，问使用 Linux 命令，实时监控日志输出显示在终端。watch 是 Linux 常见的命令行工具，watch 可以帮你监测一个命令的运行结果，省去一遍遍运行。 命令1watch [args][commond] 切换终端： Ctrl+x退出：Ctrl+g 参数-n –interval 指定间隔的时间,默认为两秒-d –differences 高亮显示变化的区域，-d=cumulative选项会把有变动过的地方都高亮显示出来-t -no-title 不显示在顶部的时间间隔和命令 示例 实时显示 Tomcat 访问记录1watch -n 1 tail -n 10 xxx_access.log 监控实时访问80端口的IP1watch -n 0.5 &apos;netstat -an | grep:80 | wc -l&apos;","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zh-h.github.io/categories/Linux/"}],"tags":[]},{"title":"ASCii Unicode Java 转换","slug":"54","date":"2016-08-16T02:40:00.000Z","updated":"2019-10-26T21:49:24.157Z","comments":true,"path":"2016/08/16/54/","link":"","permalink":"https://zh-h.github.io/2016/08/16/54/","excerpt":"","text":"如果一个仅包含基本7位ASCIII字符的Unicode文件，如果每个字符都使用2字节的原Unicode编码传输，其第一字节的8位始终为0。这就造成了比较大的浪费。对于这种情况，可以使用UTF-8编码，这是一种变长编码，它将基本7位ASCII字符仍用7位编码表示，占用一个字节（首位补0）。而遇到与其他Unicode字符混合的情况，将按一定算法转换，每个字符使用1-3个字节编码，并利用首位为0或1进行识别,这样大大节省了空间。 转换ascii =&gt; char1char char1 = 32 char =&gt; ascii1int asciiNum = (int)char1 字符串转ASCii12345678public static String string2Ascii(String value) &#123; StringBuffer sb = new StringBuffer(); char[] chars = value.toCharArray(); for (int i = 0; i &lt; chars.length; i++) &#123; sb.append((int) chars[i]).append(&quot;,&quot;); &#125; return sb.substring(0,sb.length()-1).toString();&#125; ASCii转字符串12345678public static String ascii2String(String value) &#123; StringBuffer sb = new StringBuffer(); String[] chars = value.split(&quot;,&quot;); for (int i = 0; i &lt; chars.length; i++) &#123; sb.append((char) Integer.parseInt(chars[i])); &#125; return sb.toString(); &#125; 字符转Unicode12Integer.toHexString(&apos;蛤&apos;) //十六进制Integer.toOctalString(&apos;蛤&apos;) //十进制 Unicode构造字符1(char)Integer.parseInt(&quot;103344&quot;, 16) 注意\\r 回车，ASCii码13\\n 换行，ASCii码10 空格，ASCii码32阿拉伯数字的码数(48~57)比大写字母(65~90)小，大写字母的码数比小写字母(97~122)小","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"},{"name":"坑","slug":"Java/坑","permalink":"https://zh-h.github.io/categories/Java/坑/"}],"tags":[]},{"title":"不要再写错二分查找","slug":"53","date":"2016-08-12T06:53:52.000Z","updated":"2019-10-26T21:49:24.157Z","comments":true,"path":"2016/08/12/53/","link":"","permalink":"https://zh-h.github.io/2016/08/12/53/","excerpt":"","text":"折半查找法也称为二分查找法，它充分利用了元素间的次序关系，采用分治策略，可在最坏的情况下用O(log n)完成搜索任务。但是边界问题需要严谨确定，否则陷入死循环或者找不到应有对象。12345678910111213141516171819public int find(int[] array, int value) &#123; int found = -1; int start = 0; int end = array.length - 1; // 下标范围是数目减去一 int mid; int o=1; while (start &lt;= end) &#123; // 必须是闭合区间，否则当两者差一的时候会陷入死循环 mid = (start + end) / 2; if (array[mid] == value) &#123; return mid; &#125; else if (array[mid] &lt; value) &#123; start = mid + 1; &#125; else if (array[mid] &gt; value) &#123; end = mid - 1; &#125; o++; &#125; return found; &#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zh-h.github.io/categories/数据结构与算法/"}],"tags":[]},{"title":"Ubuntu Oracle Java8","slug":"51","date":"2016-08-04T07:11:00.000Z","updated":"2019-10-26T21:49:24.157Z","comments":true,"path":"2016/08/04/51/","link":"","permalink":"https://zh-h.github.io/2016/08/04/51/","excerpt":"","text":"Oracle JDK与OpenJDK里的JVM都是HotSpot VM，从源码层面说，两者大部分是同一个东西，但是在桌面上上最重要的是GUI部分代码有较大不同，OpenJDK环境下的图像渲染效果与Oracle JDK 有较大差异。添加软件源123# 如果没有 add-apt-repository 命令# sudo apt-get install software-properties-common python-software-propertiessudo add-apt-repository ppa:webupd8team/java 更新依赖1sudo apt-get update 安装1sudo apt-get install oracle-java8-installer 查看安装后的 Java 版本1234java -versionjava version &quot;1.8.0_101&quot;Java(TM) SE Runtime Environment (build 1.8.0_101-b13)Java HotSpot(TM) 64-Bit Server VM (build 25.101-b13, mixed mode)","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"},{"name":"Linux","slug":"Java/Linux","permalink":"https://zh-h.github.io/categories/Java/Linux/"}],"tags":[]},{"title":"Apache for Windows 使用Let's Encrypt 开启SSL","slug":"49","date":"2016-08-03T19:37:00.000Z","updated":"2019-10-26T21:49:24.157Z","comments":true,"path":"2016/08/04/49/","link":"","permalink":"https://zh-h.github.io/2016/08/04/49/","excerpt":"","text":"1. 创建ssl文件目录1C:\\xampp\\apache\\conf\\ssl 2 下载签名文件和脚本 签名脚本 https://raw.githubusercontent.com/diafygi/acme-tiny/master/acme_tiny.py 中间证书 https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem 根证书 https://letsencrypt.org/certs/isrgrootx1.pem 3.创建账号和CSR 文件12openssl genrsa 4096 &gt; account.keyopenssl genrsa 4096 &gt; domain.key 用sublime把他们的编码改为UTF-8，因为Windows下会生成UTF-8 with BOM的编码文件 4. 生成 CSR 文件1openssl req -new -sha256 -key domain.key -out domain.csr 他会提示你输入各个参数，其中 Common Name 必须为你的域名 继续改编码 5. 提供验证文件访问在 Apache 的站点根目录中创建目录1C:\\xampp\\htdocs\\.well-known\\acme-challenge 6. 获取网站证书执行脚本生成证书1python acme_tiny.py --account-key ./account.key --csr ./domain.csr --acme-dir C:\\xampp\\htdocs\\.well-known\\acme-challenge &gt; ./signed.crt 7. 合并证书中间证书和网站证书1type signed.crt lets-encrypt-x3-cross-signed.pem &gt; chained.pem 根证书和中间证书1type lets-encrypt-x3-cross-signed.pem isrgrootx1.pem&gt; full_chained.pem 改编码 7. 配置 Apachehttpd.conf 中配置加载模块1LoadModule ssl_module modules/mod_ssl.so extra\\httpd-ssl.conf 中配置证书12SSLCertificateFile &quot;conf/ssl/chained.pem&quot;SSLCertificateKeyFile &quot;conf/ssl/domain.key&quot; 配置完成后可以重启 Apache 8. 设置重写规则，重定向到 HTTPS在站点目录 C:\\xampp\\htdocs\\.htaccess 配置中加入下面的规则12RewriteCond %&#123;HTTPS&#125; offRewriteRule (.*) https://%&#123;HTTP_HOST&#125;%&#123;REQUEST_URI&#125; 9. 自动更新脚本把这个批处理 renew.bat 加到计划任务中，证书有效期为90天，为即时更新证书，可以将这个脚本按时执行。1语法有错 参考来自imququ.com 《Let’s Encrypt，免费好用的 HTTPS 证书》 文中 Linux 命令行指令均已换为等同的 Windows 指令。","categories":[{"name":"默认分类","slug":"默认分类","permalink":"https://zh-h.github.io/categories/默认分类/"}],"tags":[]},{"title":"HTML5 音乐可视化","slug":"47","date":"2016-08-03T00:25:00.000Z","updated":"2019-10-26T21:49:24.157Z","comments":true,"path":"2016/08/03/47/","link":"","permalink":"https://zh-h.github.io/2016/08/03/47/","excerpt":"","text":"HEAREhttp://stackoverflow.com/questions/19398575/creating-audio-spectrum-of-youtube-stream-html5 此页面仅支持 Chrome 浏览器，手机浏览器上资源消耗较高，发热大，可用来烘干进水的手机。","categories":[{"name":"默认分类","slug":"默认分类","permalink":"https://zh-h.github.io/categories/默认分类/"}],"tags":[]},{"title":"crontab 定时执行任务命令","slug":"46","date":"2016-08-02T23:10:05.000Z","updated":"2019-10-26T21:49:24.157Z","comments":true,"path":"2016/08/03/46/","link":"","permalink":"https://zh-h.github.io/2016/08/03/46/","excerpt":"","text":"昨天参加某司的在线笔试，里面问到了 crontab 的命令格式，当时记得比较模糊，但是后来查证还是选对了。不过我更惊讶的是题目里竟然问了两道 Spring 配置文件的问题，真是的！ crond是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程，Linux发行版基本上都会包含该工具，并且会自动启动crond进程，crond进程每分钟会定期检查执行任务。 基本格式12* * * * * command 分 时 日 月 周 命令 第1列表示分钟1～59 每分钟用或者 /1表示第2列表示小时1～23（0表示0点）第3列表示日期1～31第4列表示月份1～12第5列标识号星期0～6（0表示星期天）第6列要运行的命令 示例110 1 * * 6,0 service nginx restart 表示每周六、周日的1 : 10重启Ngxin 1* 23-7/1 * * * java -jar /home/www/vblue_project/vblue.jar restart 表示晚上11点到早上7点之间，每隔一小时重启一下我的应用 10 0 1 * * /usr/loaclhost/nginx/conf/ssl/renew_cert.sh &gt;/dev/null 2&gt;&amp;1 表示每月更新我的签名证书 使用crontab -e开始编辑文件内容crontab 配置文件1234567891011121314151617181920212223# Edit this file to introduce tasks to be run by cron.# # Each task to run has to be defined through a single line# indicating with different fields when the task will be run# and what command to run for the task# # To define the time you can provide concrete values for# minute (m), hour (h), day of month (dom), month (mon),# and day of week (dow) or use &apos;*&apos; in these fields (for &apos;any&apos;).# # Notice that tasks will be started based on the cron&apos;s system# daemon&apos;s notion of time and timezones.# # Output of the crontab jobs (including errors) is sent through# email to the user the crontab file belongs to (unless redirected).# # For example, you can run a backup of all your user accounts# at 5 a.m every week with:# 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/# # For more information see the manual pages of crontab(5) and cron(8)# # m h dom mon dow command0 0 1 * * /usr/loaclhost/nginx/conf/ssl/renew_cert.sh &gt;/dev/null 2&gt;&amp;1 crontab file [-u user] 用指定的文件替代目前的crontabcrontab-[-u user] 用标准输入替代目前的crontabcrontab-1[user] 列出用户目前的crontabcrontab-e[user] 编辑用户目前的crontabcrontab-d[user] 删除用户目前的crontabcrontab-c dir 指定crontab的目录","categories":[{"name":"Linux","slug":"Linux","permalink":"https://zh-h.github.io/categories/Linux/"}],"tags":[]},{"title":"Http Servlet Proxy","slug":"45","date":"2016-07-19T19:56:00.000Z","updated":"2019-10-26T21:49:24.157Z","comments":true,"path":"2016/07/20/45/","link":"","permalink":"https://zh-h.github.io/2016/07/20/45/","excerpt":"","text":"JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象，由于JavaScript同源策略的限制，a.com 域名下无法操作b.com或是c.a.com域名下的对象。 有一种特别的方法就是使用HTTP代理实现跨域访问iFrame 在Nginx中可以很方便的配置代理1234567891011121314151617181920212223242526server &#123; listen 80 ; listen [::]:80 ipv6only=on; root /usr/share/nginx/html/typecho; index index.php index.html index.htm; server_name applehater.cn; location / &#123; try_files $uri $uri/ /index.php?$query_string; &#125; location /map/&#123; proxy_pass http://hahahha.com/map/; &#125; location ~ \\.php$ &#123; try_files $uri /index.php =404; fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_pass unix:/var/run/php/php7.0-fpm.sock; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125;&#125; 为了使计算处理尽量集成到应用中，可以使用Servlet去代理访问1234567891011121314151617181920public static void proxy(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, String targetUrl, String prefixPath) throws IOException &#123; String requestUrl = targetUrl + httpServletRequest.getRequestURI().replace(prefixPath, &quot;&quot;); Log.d(requestUrl); OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder().url(requestUrl).build(); Response response = client.newCall(request).execute(); Headers headers = response.headers(); for (String headerNameStr : headers.names()) &#123; String headerValueStr = headers.get(headerNameStr); httpServletResponse.setHeader(headerNameStr, headerValueStr); &#125; OutputStream os = httpServletResponse.getOutputStream(); byte[] data = response.body().source().readByteArray().clone(); os.write(data); os.flush(); os.close();&#125; 过程12345678 a.com/home b.com/school +----------+ +-------+ +-----------+| +-------------&gt; | +---------------&gt; | || | | | | || Browser | | Proxy | | Server || | Hello | | Hello | || | &lt;-----------+ | | &lt;---------------+ |+----------+ +-------+ +-----------+ 性能没有优化，比Nginx并发低好多。","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"}],"tags":[]},{"title":"cURL for Windows","slug":"43","date":"2016-07-16T19:00:53.000Z","updated":"2019-10-26T21:49:24.157Z","comments":true,"path":"2016/07/17/43/","link":"","permalink":"https://zh-h.github.io/2016/07/17/43/","excerpt":"","text":"https://curl.haxx.se/download.html 找到Win64 - Generic后下载归档文件。 解压到自己的软件目录，如C:\\Tools\\curl-7.49.1-win32-mingw。 添加到环境变量Path变量值为可执行文件目录C:\\Tools\\curl-7.49.1-win32-mingw\\bin。 12345C:\\Users\\zonghua&gt;curl cn.bing.com&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html lang=&quot;zh&quot; xml:lang=&quot;zh&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;//&lt;![CDATA[si_ST=new Date;//]]&gt;&lt;/script&gt;&lt;head&gt;&lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;content-type&quot;/&gt;&lt;script type=&quot;text/javascript&quot;&gt;//&lt;![CDATA[0;_G=&#123;ST:(si_ST?si_ST:new Date),Mkt:&quot;zh-CN&quot;,RTL:false,Ver:&quot;29&quot;,IG:&quot;436629975B45473580C7CEE4D458B9C4&quot;,EventID:&quot;1BEA8903F61A4B30B7EB7E9FC10B233C&quot;,V:&quot;homepage&quot;,P:&quot;SERP&quot;,DA:&quot;HK2&quot;,CID:&quot;1EB05C571F6267BB3B8C55021EC3663D&quot;,SUIH:&quot;zqS4lpMPYcKolCxjyqhzCQ&quot;,gpUrl:&quot;\\/fd\\/ls\\/GLinkPing.aspx?&quot; &#125;; _G.lsUrl=&quot;/fd/ls/l?IG=&quot;+_G.IG+&quot;&amp;CID=&quot;+_G.CID ;curUrl=&quot;http:\\/\\/cn.bing.com\\/&quot;;function si_T(a)&#123; if(document.images)&#123;_G.GPImg=new Image;_G.GPImg.src=_G.gpUrl+&apos;IG=&apos;+_G.IG+&apos;&amp;CID=&apos;+_G.CID+&apos;&amp;&apos;+a;&#125;return true;&#125;;... 类似PHP的curl扩展，可以封装一个Java的类库，cURL参数构造模板，文件上传下载使用缓存文件，进程ID防止锁。","categories":[{"name":"默认分类","slug":"默认分类","permalink":"https://zh-h.github.io/categories/默认分类/"},{"name":"curl","slug":"默认分类/curl","permalink":"https://zh-h.github.io/categories/默认分类/curl/"}],"tags":[]},{"title":"【搬砖】交换两个变量，不使用第三个变量","slug":"42","date":"2016-07-14T04:20:03.000Z","updated":"2019-10-26T21:49:24.156Z","comments":true,"path":"2016/07/14/42/","link":"","permalink":"https://zh-h.github.io/2016/07/14/42/","excerpt":"","text":"123a=a+b;b=a-b;a=a-b; 两个数太大可能出现数值溢出，所以可以用异或运算 123a=a^b;b=a^b;a=a^b;","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"},{"name":"原理","slug":"Java/原理","permalink":"https://zh-h.github.io/categories/Java/原理/"}],"tags":[]},{"title":"自己动手来实现Dispatcher原理","slug":"41","date":"2016-07-12T22:43:00.000Z","updated":"2019-10-26T21:49:24.156Z","comments":true,"path":"2016/07/13/41/","link":"","permalink":"https://zh-h.github.io/2016/07/13/41/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@interface Controller &#123;&#125;@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)@interface Get &#123; String value();&#125;@Controllerclass MyApplication &#123; public static void main(String[] args) &#123; SummerBootApplication.run(MyApplication.class); &#125; @Get(&quot;/index&quot;) String index() &#123; return &quot;This is index page&quot;; &#125; @Get(&quot;/about&quot;) String about() &#123; return &quot;A simple mvc showcases&quot;; &#125;&#125;public class SummerBootApplication &#123; static Map&lt;String, Object&gt; bucket = new HashMap&lt;String, Object&gt;(); static List&lt;String&gt; classFilePaths = new ArrayList&lt;String&gt;(); static Map&lt;String, Object&gt; mappiing = new HashMap&lt;String, Object&gt;(); static void readClassName(File file) &#123; String fileName = file.getName(); if (file.isFile() &amp;&amp; fileName.endsWith(&quot;.class&quot;) &amp;&amp; !fileName.contains(&quot;$&quot;)) &#123; classFilePaths.add(file.getPath()); &#125; else if (file.isDirectory()) &#123; File[] files = file.listFiles(new FilenameFilter() &#123; public boolean accept(File dir, String name) &#123; if (name.endsWith(&quot;.class&quot;) &amp;&amp; !name.contains(&quot;$&quot;)) &#123; return true; &#125; else &#123; return false; &#125; &#125; &#125;); for (File fileItem : files) &#123; readClassName(fileItem);//递归读取类文件 &#125; &#125; &#125; static void loadClass(String className) &#123; Class&lt;?&gt; controllerClass = null; try &#123; controllerClass = Class.forName(className); Controller controllerAnnotaion = controllerClass.getAnnotation(Controller.class); if (controllerAnnotaion != null) &#123; Method[] methods = controllerClass.getDeclaredMethods(); for (Method method : methods) &#123; Get getMethodAnnotaion = method.getAnnotation(Get.class); if (getMethodAnnotaion != null) &#123; Object controllerObject = controllerClass.newInstance(); String getPath = getMethodAnnotaion.value(); bucket.put(className, controllerObject); mappiing.put(getPath, className + &quot;@&quot; + method.getName()); &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; static void response(String message) &#123; System.out.println(message); &#125; static void dispatcher(String path) &#123; Set&lt;String&gt; keySet = mappiing.keySet(); boolean isNotFound = true; for (String matchPath : keySet) &#123;//这里使用了最简单的线性搜索 if (path.startsWith(matchPath)) &#123;//直接判断路径匹配，或者可以使用正则 isNotFound = false; String controllerClassNameAndMethodName = (String) mappiing.get(matchPath); String[] names = controllerClassNameAndMethodName.split(&quot;@&quot;); String controllerClassName = names[0]; String methodName = names[1]; handle(controllerClassName, methodName);//后续可以给handle传入请求对象 &#125; &#125; if (isNotFound) &#123; System.out.println(&quot;404&quot;); &#125; &#125; public static void handle(String controllerClassName, String methodName) &#123; Object controller = getBean(controllerClassName); Class&lt;?&gt; controllerClass = controller.getClass(); try &#123; Method handleMethod = controllerClass.getDeclaredMethod(methodName); Class&lt;?&gt; returnType = handleMethod.getReturnType(); Object returnObject = handleMethod.invoke(controller);//调用处理方法 response(returnObject.toString()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; static void fillBucket(String rootFilePath, String classPath) &#123; classPath = classPath.replace(&quot;/&quot;, &quot;\\\\&quot;).substring(1, classPath.length() - 1); File rootFile = new File(rootFilePath); readClassName(rootFile); for (String classFilePath : classFilePaths) &#123; String className = classFilePath.replace(classPath, &quot;&quot;) .replace(&quot;.class&quot;, &quot;&quot;) .replace(&quot;\\\\&quot;, &quot;.&quot;); className = className.substring(1, className.length()); loadClass(className); &#125; &#125; public static void run(Class clazz) &#123; String rootFilePath = clazz.getResource(&quot;&quot;).getFile(); String classPath = clazz.getClassLoader().getResource(&quot;&quot;).getPath(); fillBucket(rootFilePath, classPath); Scanner scanner = new Scanner(System.in); System.out.println(&quot;Winter Boot application listening&quot;); while (true) &#123; String path = scanner.nextLine(); if (path.equals(&quot;bye&quot;)) &#123; break; &#125; dispatcher(path); &#125; &#125; public static Object getBean(String className) &#123; return bucket.get(className);//通过其他设置，可以实现懒加载或者多次实例化而不是单例 &#125;&#125; 运行结果,匹配路径在控制台输入做演示 123456789Winter Boot application listening/indexThis is index page/aboutA simple mvc showcases/about?page=3A simple mvc showcases/sdhfsdhf404","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"},{"name":"原理","slug":"Java/原理","permalink":"https://zh-h.github.io/categories/Java/原理/"}],"tags":[]},{"title":"ORM原理实现","slug":"40","date":"2016-07-12T22:25:00.000Z","updated":"2019-10-26T21:49:24.156Z","comments":true,"path":"2016/07/13/40/","link":"","permalink":"https://zh-h.github.io/2016/07/13/40/","excerpt":"","text":"ORM全称“Object Relational Mapping”，即对象-关系映射，简单来说就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表。 Python语言的ORM框架基本原理是元类来实现，而Java中的框架一般使用反射实现类字段和数据表字段的映射123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Doge &#123; private String name; private Integer age; public Doge(String name, Integer age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125;public class MyORM &#123; public void save(Object object) &#123; Class&lt;?&gt; objectClass = object.getClass(); Method[] methods = objectClass.getMethods(); StringBuffer fieldsListStr = new StringBuffer(); StringBuffer valuesListStr = new StringBuffer(); StringBuffer insertStatement = new StringBuffer(); String className = objectClass.getSimpleName().toLowerCase(); for (Method method : methods) &#123; String methodName = method.getName(); if (methodName.startsWith(&quot;get&quot;) &amp;&amp; !methodName.equals(&quot;getClass&quot;)) &#123; String fieldName = methodName.substring(3, methodName.length()).toLowerCase(); fieldsListStr.append(fieldName); fieldsListStr.append(&quot;,&quot;); try &#123; Object valueObject = method.invoke(object); if (valueObject instanceof String) &#123; valuesListStr.append((String) valueObject); &#125; else if (valueObject instanceof Integer) &#123; valuesListStr.append(((Integer) valueObject).intValue()); &#125;//如果是其他关联类型的话就用递归去执行 valuesListStr.append(&quot;,&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; insertStatement.append(&quot;insert into &quot;); insertStatement.append(className); insertStatement.append(&quot;(&quot;); insertStatement.append(fieldsListStr.substring(0, fieldsListStr.length() - 1)); insertStatement.append(&quot;)values(&quot;); insertStatement.append(valuesListStr.substring(0, valuesListStr.length() - 1)); insertStatement.append(&quot;);&quot;); Log.d(insertStatement); &#125; public static void main(String[] args) &#123; Doge dodge = new Doge(&quot;Ba Gong&quot;, 9); MyORM myORM = new MyORM(); myORM.save(dodge); &#125;&#125; 生成的语句1insert into doge(name,age)values(&quot;Bagong&quot;,9); 通过反射可以获取对象的属性名称和值，然后拼接成插入语句，这样可以使得ORM的方法具有通用性，不需要每一个对象都写CRUD方法。实际运用中需要完成对关联对象的查询，对注解信息的读出以及缓存（每次执行反射的性能损耗是不小的）","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"},{"name":"原理","slug":"Java/原理","permalink":"https://zh-h.github.io/categories/Java/原理/"}],"tags":[]},{"title":"我的IOC原理实现——使用注解读取元数据","slug":"39","date":"2016-07-12T22:02:00.000Z","updated":"2019-10-26T21:49:24.156Z","comments":true,"path":"2016/07/13/39/","link":"","permalink":"https://zh-h.github.io/2016/07/13/39/","excerpt":"","text":"IOC容器就是具有依赖注入功能的容器，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。应用程序无需直接在代码中实例化的对象，应用程序由IOC容器进行组装。 以往一般使用基于XML配置文件进行配置元数据，Spring与配置文件完全解耦。但是编写XML定义读取实在是过于繁琐，所以近来都倾向使用注解配置。 模仿 Spring Boot 对目录下的包进行扫描，读取Bean注解的就通过反射将它实例化，字段value注解就对字段赋值。 实例为均为单例模式，暂时未考虑到多线程冲突的情况。 画成这样了 123456789101112131415 instanite +---------------------+ +-------+ |WinterBootApplication| +---------&gt; | Car | +------+-------------++ +---+---+ | | ^ | | set value | | read file | | | | +---+----+ v +---------------&gt; | @Bean | | read annotation +--------+ +-----------+ | | Car.class | | +-----------+ | +---------+ +---------------&gt; | @Value | +---------+ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@interface Bean &#123;&#125;@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)@interface Value &#123; String value();&#125;@Beanclass Car &#123; @Value(&quot;beetle&quot;) private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; final StringBuffer sb = new StringBuffer(&quot;Car&#123;&quot;); sb.append(&quot;name=&apos;&quot;).append(name).append(&apos;\\&apos;&apos;); sb.append(&apos;&#125;&apos;); return sb.toString(); &#125;&#125;class MyApplication &#123; public static void main(String[] args) &#123; WinterBootApplication.run(MyApplication.class); Car car = (Car) WinterBootApplication.getBean(&quot;me.zonghua.spring.concept.ioc.Car&quot;); Log.d(car); &#125;&#125;public class WinterBootApplication &#123; static Map&lt;String, Object&gt; bucket = new HashMap&lt;String, Object&gt;(); static List&lt;String&gt; classFilePaths = new ArrayList&lt;String&gt;(); /** * 首字母大写的最优方法 * * @param name * @return */ static String captureName(String name) &#123; char[] cs = name.toCharArray(); cs[0] -= 32; return String.valueOf(cs); &#125; static void readClassName(File file) &#123; String fileName = file.getName(); if (file.isDirectory()) &#123; File[] files = file.listFiles(new FilenameFilter() &#123; public boolean accept(File dir, String name) &#123; if (name.endsWith(&quot;.class&quot;) &amp;&amp; !name.contains(&quot;$&quot;)) &#123; return true; &#125; else &#123; return false; &#125; &#125; &#125;); for (File fileItem : files) &#123; readClassName(fileItem);//递归读取类文件 &#125; &#125; else if (file.isFile() &amp;&amp; fileName.endsWith(&quot;.class&quot;) &amp;&amp; !fileName.contains(&quot;$&quot;)) &#123; classFilePaths.add(file.getPath()); &#125; &#125; static void loadClass(String className) &#123; try &#123; Class&lt;?&gt; beanClass = Class.forName(className); Bean beanAnnotation = beanClass.getAnnotation(Bean.class); if (beanAnnotation != null) &#123;//更改有Bean注解的类 Object bean = beanClass.newInstance(); Field[] fields = beanClass.getDeclaredFields();//获取所有声明的字段 for (Field field : fields) &#123; Value valueAnnotation = field.getAnnotation(Value.class); if (valueAnnotation != null) &#123; String value = valueAnnotation.value(); String fieldName = field.getName(); String setMethodName = &quot;set&quot; + captureName(fieldName);//获取set方法名 Log.d(&quot;setMethod : &quot; + setMethodName + &quot;(&quot; + value + &quot;)&quot;); Method setMethod = beanClass.getMethod(setMethodName, String.class); setMethod.invoke(bean, value);//动态执行 &#125; &#125; bucket.put(className, bean);//存放到容器 &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void run(Class clazz) &#123; String rootFilePath = clazz.getResource(&quot;&quot;).getFile(); String classPath = clazz.getClassLoader().getResource(&quot;&quot;).getPath(); classPath = classPath.replace(&quot;/&quot;, &quot;\\\\&quot;).substring(1, classPath.length() - 1); File rootFile = new File(rootFilePath); readClassName(rootFile); for (String classFilePath : classFilePaths) &#123; String className = classFilePath.replace(classPath, &quot;&quot;) .replace(&quot;.class&quot;, &quot;&quot;) .replace(&quot;\\\\&quot;, &quot;.&quot;); className = className.substring(1, className.length()); loadClass(className); &#125; &#125; public static Object getBean(String className) &#123; return bucket.get(className);//通过其他设置，可以实现懒加载或者多次实例化而不是单例 &#125;&#125; 运行结果12setMethod : setName(beetle)Car&#123;name=&apos;beetle&apos;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"},{"name":"原理","slug":"Java/原理","permalink":"https://zh-h.github.io/categories/Java/原理/"}],"tags":[]},{"title":"Java 注解简述","slug":"38","date":"2016-07-11T23:22:00.000Z","updated":"2019-10-26T21:49:24.156Z","comments":true,"path":"2016/07/12/38/","link":"","permalink":"https://zh-h.github.io/2016/07/12/38/","excerpt":"","text":"Java内置了@Override等注解，在类如Spring Framework等框架中更是大量使用了注解。 注解使得Java源代码中不但可以包含功能性的实现代码，还可以添加元数据，就相当于以往的XML配置文件与Java源文件紧密结合，不再担两者同步修改造成的困扰。 在注明RetentionPolicy为运行时类型时，需要Java反射来提供了在运行时刻读取注解信息的支持。否则只是需要在编译时获取到注解信息（如@SupressWarnings） 示例应用12345678910111213141516171819202122232425262728293031323334353637383940414243@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.PARAMETER&#125;)@interface NameAnnotaion &#123; String name();&#125;@NameAnnotaion(name = &quot;test type&quot;)public class ReflectAnnotation &#123; @NameAnnotaion(name = &quot;test annotation&quot;)//如果名为value就不用特例写出来 public void test() &#123; System.out.println(&quot;doge&quot;); &#125; public void test(@NotNull @NameAnnotaion(name = &quot;test parameter&quot;) String message) &#123; System.out.println(message); &#125; public static void main(String[] args) &#123; ReflectAnnotation ra = new ReflectAnnotation(); NameAnnotaion raClassAnnotaion = ra.getClass().getAnnotation(NameAnnotaion.class); Log.d(raClassAnnotaion.name()); try &#123; Method testMethod = ra.getClass().getMethod(&quot;test&quot;); NameAnnotaion testMethodAnnotaion = testMethod.getAnnotation(NameAnnotaion.class); Log.d(testMethodAnnotaion.name()); Method testMethod1 = ra.getClass().getMethod(&quot;test&quot;, String.class); Annotation[][] annotations = testMethod1.getParameterAnnotations(); Class[] parameterTypes = testMethod1.getParameterTypes();//方法有多个参数类型 for (Annotation[] annotations1 : annotations) &#123; //外层循环参数 for (Annotation annotation : annotations1) &#123;//里层循环参数的多个注解 if (annotation instanceof NameAnnotaion) &#123; NameAnnotaion nameAnnotaion = (NameAnnotaion) annotation; Log.d(nameAnnotaion.name()); &#125; &#125; &#125; &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"},{"name":"原理","slug":"Java/原理","permalink":"https://zh-h.github.io/categories/Java/原理/"}],"tags":[]},{"title":"Java 反射应用示例","slug":"37","date":"2016-07-11T05:58:00.000Z","updated":"2019-10-26T21:49:24.156Z","comments":true,"path":"2016/07/11/37/","link":"","permalink":"https://zh-h.github.io/2016/07/11/37/","excerpt":"","text":"原理反射指的是应用通过采用某种机 制来实现对自己行为的描述（self-representation）和监测（examination），并能根据自身行为的状态和结果，调整或修改应用 所描述行为的状态和相关的语义。 在JVM中有一个运行时内存，分为方法区，堆区和栈区。我们这里需要了解的主要是方法区，方法区的主要作用是存储被装载的类的类型信息，当JVM装载某个类型的时候，类装载器定位相应的class文件，然后将其读入到JVM中，紧接着JVM提取class中的类型信息，将这些信息存储到方法区中，后续可以从方法区获取信息。1234567891011 reflection Kitty.java kitty stack + + ^ | | | |complie getClass instantiate | | | v load v + Kitty.class +-------------&gt; Kitty heap include meta method 实现动态代理动态代理可以运用在自动关闭资源，如文件读取，数据库连接等；也可以用在声明式事务中，代码简约模块化；123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566interface Animal &#123; void say(String message); void doIndexException(); void setName(String name);&#125;class Kitty implements Animal &#123; private String name = &quot;kitty&quot;; public void say(String message) &#123; System.out.println(name + &quot; : &quot; + message); &#125; public void doIndexException() &#123; String[] args = new String[]&#123;&quot;zonghua&quot;&#125;; System.out.println(args[2]); &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;class SpeakInvocationHandler implements InvocationHandler &#123; private Object origin; public Object advise(Object origin) &#123; this.origin = origin; return Proxy.newProxyInstance(origin.getClass().getClassLoader(), origin .getClass().getInterfaces(), this);//返回代理对象 &#125; public Object invoke(Object proxy, Method method, Object[] args) &#123; if (method.getName().equals(&quot;say&quot;)) &#123; args = new String[]&#123;&quot;haha&quot;&#125;;//把代理对象方法篡改了； &#125; Object returnParameter = null; try &#123; returnParameter = method.invoke(this.origin, args); &#125; catch (Exception e) &#123;//这里可以进行捕获异常 Log.d(e); &#125; try &#123; Method setNameMethod = origin.getClass().getMethod(&quot;setName&quot;, String.class); setNameMethod.invoke(origin, &quot;lily&quot;);//篡改原对象属性 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return returnParameter;//可以篡改返回参数 &#125;&#125;public class DynamicProxy &#123; public static void main(String[] args) &#123; SpeakInvocationHandler speakInvocationHandler = new SpeakInvocationHandler(); Animal kitty = (Animal) speakInvocationHandler.advise(new Kitty()); kitty.say(&quot;meo&quot;); kitty.doIndexException(); kitty.say(&quot;meo&quot;); &#125;&#125; 1. 获取实例的包名和类名1234567public class FullName &#123; public static void main(String[] args) &#123; FullName fullName = new FullName(); Log.d(fullName.getClass().getName()); &#125;&#125; 2. 用类名实例化类1234567891011121314151617181920212223242526272829class User&#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;public class ClassInstance &#123; public static void main(String[] args) &#123; Class&lt;?&gt; userClass= null; try &#123; userClass = Class.forName(&quot;me.zonghua.spring.concept.reflect.ClassInstance&quot;); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; User user = null; try &#123; user = (User)userClass.newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 3. 获取执行方法1234567891011121314151617public class MethodAndName &#123; public void say(String message)&#123; System.out.println(&quot;I say &quot;+message); &#125; public static void main(String[] args) &#123; MethodAndName methodAndName = new MethodAndName(); try &#123; Method sayMethod = methodAndName.getClass() .getMethod(&quot;say&quot;,String.class);//方法重载 Log.d(sayMethod.getName());//Spring Data JPA可以通过解析方法名为查询参数 sayMethod.invoke(methodAndName,&quot;loving you&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 4. 获取改写字段123456789101112131415public class GetSetter &#123; private String message; public static void main(String[] args) &#123; GetSetter getSetter = new GetSetter(); try &#123; Field messageField = getSetter.getClass().getDeclaredField(&quot;message&quot;); messageField.setAccessible(true); messageField.set(getSetter, &quot;zonghua&quot;); Log.d(getSetter.message); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 5. 获取类装载器123456public class ClassLoaderDemo &#123; public static void main(String[] args) &#123; ClassLoaderDemo classLoaderDemo = new ClassLoaderDemo(); Log.d(classLoaderDemo.getClass().getClassLoader().getClass().getName()); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"}],"tags":[]},{"title":"结合个人理解的Spring事务基本原理","slug":"36","date":"2016-07-11T04:49:00.000Z","updated":"2019-10-26T21:49:24.156Z","comments":true,"path":"2016/07/11/36/","link":"","permalink":"https://zh-h.github.io/2016/07/11/36/","excerpt":"","text":"之前面试时问到Spring事务的原理和事务传播模式。 Spring所支持的事务传播模式： PROPAGATION_REQUIRED–默认的支持当前事务，如果当前没有事务，就新建一个事务。 PROPAGATION_SUPPORTS–支持当前事务，如果当前没有事务，就以非事务方式执行。 PROPAGATION_MANDATORY–支持当前事务，如果当前没有事务，就抛出异常。 PROPAGATION_REQUIRES_NEW–新建事务，如果当前存在事务，把当前事务挂起。 PROPAGATION_NOT_SUPPORTED–以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 PROPAGATION_NEVER–以非事务方式执行，如果当前存在事务，则抛出异常。 PROPAGATION_NESTED–如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。 //整理中","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"},{"name":"spring","slug":"Java/spring","permalink":"https://zh-h.github.io/categories/Java/spring/"}],"tags":[]},{"title":"【搬砖】全排列","slug":"35","date":"2016-07-11T01:16:00.000Z","updated":"2019-10-26T21:49:24.156Z","comments":true,"path":"2016/07/11/35/","link":"","permalink":"https://zh-h.github.io/2016/07/11/35/","excerpt":"","text":"题目给三个字符，例如abc，取得他的全排列abc, acb, bca, dac, cab, cba 解答1. 递归和容器实现全排列123456789101112131415161718192021222324252627282930313233public class Allrange &#123; ArrayList&lt;String&gt; bucket = new ArrayList&lt;String&gt;(); public static void main(String[] args) &#123; String str = &quot;123&quot;; new Allrange().range(str); &#125; void swap(char[] chars, int a, int b) &#123; char temp = chars[a]; chars[a] = chars[b]; chars[b] = temp; &#125; void range(String str) &#123; int strLength = str.length(); char[] chars = str.toCharArray(); for (int i = 0; i &lt; strLength; i++) &#123; if (i == strLength - 1) &#123;//如果是最后一个字符的时候，和第一个替换 swap(chars, i, 0); &#125; else &#123; swap(chars, i, i + 1);//和后一个字符替换 &#125; String result = String.valueOf(chars); if(!bucket.contains(result))&#123; Log.d(result); bucket.add(result); range(result);//输出里含有这个字符就继续排列，直到输出里面没有 &#125; &#125; &#125;&#125; 输出123456213123231321312132 算法复杂度分析流程1234567891011 123 213 231 312 312 X123 132 123 X 231 X 231 X 321 312 X 123 X 第一级递归把结果放到容器，第二级递归使用了ArrayList的contains方法判断是否在容器内，不在容器内的就继续递归。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://zh-h.github.io/categories/数据结构与算法/"}],"tags":[]},{"title":"BUG!HttpServletRequest#getCookies()在iPhone的Safari浏览器浏览时出现null异常","slug":"33","date":"2016-06-11T06:36:00.000Z","updated":"2019-10-26T21:49:24.156Z","comments":true,"path":"2016/06/11/33/","link":"","permalink":"https://zh-h.github.io/2016/06/11/33/","excerpt":"","text":"服务端1234567String cookieValue = null;Cookie[] cookies = httpServletRequest.getCookies();//会出现空指针异常for (Cookie cookie : cookies) &#123; if (cookie.getName().equals(ASP_NET_SESSION_ID)) &#123; cookieValue = cookie.getValue(); &#125;&#125; 浏览器12345678910111213141516171819202122232425262728293031323334var http = &#123; post: function (url, data, successFunc, errorFunc) &#123; if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari var xmlhttp = new XMLHttpRequest(); &#125; else &#123;// code for IE6, IE5 var xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; xmlhttp.onreadystatechange = function () &#123; if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) &#123; var response = xmlhttp.responseText; if (response.indexOf(&quot;errors&quot;) == -1) &#123; successFunc(xmlhttp.responseText); &#125; else &#123; errorFunc(500, response); &#125; &#125; else if (xmlhttp.status == 500) &#123; errorFunc(500, &quot;Server is busy&quot;); &#125; else if (xmlhttp.status == 404) &#123; errorFunc(404, &quot;Server not found&quot;); &#125; &#125; xmlhttp.timeout = 5000 //milliseconds xmlhttp.ontimeout = function (e) &#123; errorFunc(502, &quot;Server process timeout&quot;); &#125; xmlhttp.open(&quot;POST&quot;, url, true); xmlhttp.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); xmlhttp.send(data); &#125;, get: function (url, successFunc, errorFunc) &#123; &#125;&#125; 详情未知12345java.lang.NullPointerException: null at org.vblue.vblue.edu.util.Log.d(Log.java:8) ~[classes/:na] at org.vblue.vblue.edu.web.LmsController.elective(LmsController.java:150) ~[classes/:na] at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_66] at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_66] 调试发现接收的request头没有包含cookie,并且getCookies()这个方法会抛出null异常，而不是直接返回一个null值 header 再次检查设置cookie的方法12345678910111213OutputStream outputStream = httpServletResponse.getOutputStream();if (response.isSuccessful()) &#123; String cookieString = response.header(&quot;Set-Cookie&quot;); String cookieValue = StringUtil.parseCookie(cookieString, ASP_NET_SESSION_ID_MATCH); Cookie cookie = new Cookie(ASP_NET_SESSION_ID, cookieValue); cookie.setPath(&quot;N/A&quot;); httpServletResponse.addCookie(cookie); byte[] data = response.body().source().readByteArray().clone(); outputStream.write(data); outputStream.close();&#125; else &#123; outputStream.write(0);&#125; 设置的Cookie cookie Fixed1//cookie.setPath(&quot;N/A&quot;); 注释掉这里，Safari不接受。原意是设置一个全路径匹配的Cookie Cookie 的相关规范一个遵循 Netscape cookie 草案的完整的 Set-Cookie 头：12Set-Cookie：customer=huangxp; path=/foo; domain=.ibm.com; expires= Wednesday, 19-OCT-05 23:12:40 GMT; [secure] Customer=huangxp 一个”名称＝值”对，把名称 customer 设置为值”huangxp”，这个属性在 Cookie 中必须有。 path=/foo 控制哪些访问能够触发 cookie 的发送。如果没有指定 path，cookie 会在所有对此站点的 HTTP 传送时发送。如果 path=/directory，只有访问 /directory 下面的网页时，cookie 才被发送。在这个例子中，用户在访问目录 /foo 下的内容时，浏览器将发送此 cookie。如果指定了 path，但是 path 与当前访问的 url 不符，则此 cookie 将被忽略。 domain=.ibm.com 指定 cookie 被发送到哪台计算机上。正常情况下，cookie 只被送回最初向用户发送 cookie 的计算机。在这个例子中，cookie 会被发送到任何在 .ibm.com 域中的主机。如果 domain 被设为空，domain 就被设置为和提供 cookie 的 Web 服务器相同。如果 domain 不为空，并且它的值又和提供 cookie 的 Web 服务器域名不符，这个 Cookie 将被忽略。 expires= Wednesday, 19-OCT-05 23:12:40 GMT 指定 cookie 失效的时间。Servlet规范里面是设置一个单位为秒的长整型。 secure 如果 secure 这个词被作为 Set-Cookie 头的一部分，那么 cookie 只能通过安全通道传输（目前即 SSL 通道）。否则，浏览器将忽略此 Cookie。 之前参考Chrome上显示的path的值设置为’N/A’，意为不指定path，但并不符合规范，所以Safari没有接受这个Cookie，导致后续接受Cookie的时候出现异常。","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"},{"name":"bug","slug":"Java/bug","permalink":"https://zh-h.github.io/categories/Java/bug/"},{"name":"servlet","slug":"Java/bug/servlet","permalink":"https://zh-h.github.io/categories/Java/bug/servlet/"}],"tags":[]},{"title":"Java 类装载与资源路径的获取","slug":"32","date":"2016-06-09T03:20:00.000Z","updated":"2019-10-26T21:49:24.155Z","comments":true,"path":"2016/06/09/32/","link":"","permalink":"https://zh-h.github.io/2016/06/09/32/","excerpt":"","text":"类加载当程序需要的某个类,那么需要通过类加载器把类的二进制加载到内存中,位于堆区。类加载器是Java类或者是C++类（Boostrap） 123456789101112131415161718192021+----------------+ | Boostrap | JRE/lib/rt.jar +--------+-------+ ^ | | +--------+-------+ | ExtClassLoader | JRE/lib/ext/*.jar+--------+-------+ ^ | | +--------+-------+ | AppClassLoader | ClassPath +--------+-------+ ^ | | +--------+-------+ | YoursClassLoade| Custom +----------------+ 1. 启动（Bootstrap）类加载器：引导类装入器是用本地代码实现的类装入器，它负责将JRE/lib下面的类库加载到内存中。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。 2. 标准扩展（Extension）类加载器：扩展类加载器是由 Sun 的ExtClassLoader(sun.misc.Launcher$ExtClassLoader)实现的。它负责将JRE/lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中。 3. 系统（System）类加载器：系统类加载器是由 Sun 的AppClassLoader(sun.misc.Launcher$AppClassLoader)实现的。它负责将系统类路径CLASSPATH中指定的类库加载到内存中。 4. 自定义的类加载器：使用ClassLoader.loadClass()方法。 双亲委派机制当某个类加载器执行加载类任务时，首先将加载任务委托给父类加载器，一直上交，当父父父类加载器完成类加载任务，就成功返回；当父类加载器无法完成此加载任务时，由自身去加载。 加载并实例化类在SQL操作中Class.forName(&quot;com.mysql.jdbc.Driver&quot;);加载了驱动类，并实例化。DriverManager.getConnection()依赖驱动，在内从中获取驱动的实例，然后执行相应的操作。 资源获取类加载器中的方法可以用来获取*.java文件的一些信息。如读取类路径的文件，如 Maven 项目中的 resources 目录下的文件。123456789101112131415161718192021public static String readTranslateJsonFileToString(String resourceName) &#123; ClassLoader classLoader = LocationTranslateUtil.class.getClassLoader(); URL resource = classLoader.getResource(resourceName); StringBuilder content = new StringBuilder(); if (resource != null) &#123; File file = new File(resource.getFile()); InputStream is; try &#123; is = new FileInputStream(file); InputStreamReader isr = new InputStreamReader(is, \"UTF-8\"); BufferedReader br = new BufferedReader(isr); String temp; while ((temp = br.readLine()) != null) &#123; content.append(temp); &#125; &#125; catch (IOException e) &#123; // TODO &#125; &#125; return content.toString();&#125; ClassLoader的作用 Spring ResourcesInterface1234567891011121314151617public interface Resource extends InputStreamSource &#123; boolean exists(); boolean isOpen(); URL getURL() throws IOException; File getFile() throws IOException; Resource createRelative(String relativePath) throws IOException; String getFilename(); String getDescription();&#125; Default implement12345678910111213public Resource getResource(String location) &#123; Assert.notNull(location, &quot;Location must not be null&quot;); if(location.startsWith(&quot;classpath:&quot;)) &#123; return new ClassPathResource(location.substring(&quot;classpath:&quot;.length()), this.getClassLoader()); &#125; else &#123; try &#123; URL url = new URL(location); return new UrlResource(url); &#125; catch (MalformedURLException var3) &#123; return this.getResourceByPath(location); &#125; &#125; &#125; Usage12345678 classpath:com/myapp/config.xml // Loaded from the classpath.file:///data/config.xml // Loaded as a URL, from the filesystem. [1]http://myserver/logo.png // Loaded as a URL. /data/config.xml // Depends on the underlying ApplicationContext. Base on webapp while running on IDE","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"},{"name":"原理","slug":"Java/原理","permalink":"https://zh-h.github.io/categories/Java/原理/"}],"tags":[]},{"title":"Django 返回图片流","slug":"30","date":"2016-05-21T19:30:47.000Z","updated":"2019-10-26T21:49:24.155Z","comments":true,"path":"2016/05/22/30/","link":"","permalink":"https://zh-h.github.io/2016/05/22/30/","excerpt":"","text":"1234567891011def showcode(request): from Captcha.Visual.Tests import PseudoGimpy g = PseudoGimpy() i = g.render() out = StringIO() i.save(out, &quot;GIF&quot;) out.seek(0) response = HttpResponse() response[&apos;Content-Type&apos;] = &apos;image/gif&apos; response.write(out.read()) return response","categories":[{"name":"Django","slug":"Django","permalink":"https://zh-h.github.io/categories/Django/"},{"name":"Python","slug":"Django/Python","permalink":"https://zh-h.github.io/categories/Django/Python/"}],"tags":[]},{"title":"Nginx 使用 Let's Encrypt 证书开启SSL","slug":"27","date":"2016-04-28T00:39:00.000Z","updated":"2019-10-26T21:49:24.155Z","comments":true,"path":"2016/04/28/27/","link":"","permalink":"https://zh-h.github.io/2016/04/28/27/","excerpt":"","text":"创建ssl文件目录 1/usr/local/nginx/conf/ssl 创建账号 1openssl genrsa 4096 &gt; account.key 创建 CSR 文件 1openssl genrsa 4096 &gt; domain.key 或者 ECC 私钥1openssl ecparam -genkey -name secp384r1 | openssl ec -out domain.key 生成 CSR 文件 1openssl req -new -sha256 -key domain.key -subj &quot;/&quot; -reqexts SAN -config &lt;(cat /etc/ssl/openssl.cnf &lt;(printf &quot;[SAN]\\nsubjectAltName=DNS:applehater.cn&quot;)) &gt; domain.csr 提供验证文件访问创建虚拟网站 1mkdir /usr/share/nginx/html/challenges 配置nginx访问目录12345678910111213141516171819server &#123; server_name applehater.cn; server_tokens off; access_log /dev/null; if ($request_method !~ ^(GET|HEAD|POST)$ ) &#123; return 444; &#125; location ^~ /.well-known/acme-challenge/ &#123; alias /usr/share/nginx/html/challenges/; try_files $uri =404; &#125; location / &#123; rewrite ^/(.*)$ https://applehater.cn/$1 permanent; &#125; &#125; 获取网站证书1wget https://raw.githubusercontent.com/diafygi/acme-tiny/master/acme_tiny.py 执行脚本生成证书1python acme_tiny.py --account-key ./account.key --csr ./domain.csr --acme-dir ~/www/challenges/ &gt; ./signed.crt 合并证书中间证书和网站证书12wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &gt; intermediate.pemcat signed.crt intermediate.pem &gt; chained.pem 根证书和中间证书12wget -O - https://letsencrypt.org/certs/isrgrootx1.pem &gt; root.pemcat intermediate.pem root.pem &gt; full_chained.pem 配置主站 1234567891011121314151617181920212223242526272829303132server &#123; listen 443 ssl http2 fastopen=3 reuseport; root /usr/share/nginx/html/typecho; index index.php index.html index.htm; server_name applehater.cn api.applehater.cn; ssl on; ssl_certificate /usr/local/nginx/conf/ssl/chained.pem; ssl_certificate_key /usr/local/nginx/conf/ssl/domain.key; ssl_ciphers EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5; ssl_prefer_server_ciphers on; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_session_cache shared:SSL:50m; ssl_session_timeout 1d; ssl_session_tickets on; ssl_trusted_certificate /usr/local/nginx/conf/ssl/full_chained.pem; resolver 114.114.114.114 valid=300s; resolver_timeout 10s; access_log /dev/null; location / &#123; try_files $uri $uri/ /index.php?$query_string; &#125; location ~ \\.php$ &#123; try_files $uri /index.php =404; fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_pass unix:/var/run/php/php7.0-fpm.sock; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; &#125; 自动更新脚本 1234567#!/bin/bashcd /usr/local/nginx/conf/sslpython acme_tiny.py --account-key account.key --csr domain.csr --acme-dir /usr/share/nginx/html/challenges/ &gt; signed.crt || exitwget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &gt; intermediate.pemcat signed.crt intermediate.pem &gt; chained.pemservice nginx reload 证书有效期为90天，为即时更新证书，可以将这个脚本按时执行。 原文来自imququ.com 《Let’s Encrypt，免费好用的 HTTPS 证书》","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://zh-h.github.io/tags/nginx/"},{"name":"Linux","slug":"Linux","permalink":"https://zh-h.github.io/tags/Linux/"},{"name":"ssl","slug":"ssl","permalink":"https://zh-h.github.io/tags/ssl/"},{"name":"https","slug":"https","permalink":"https://zh-h.github.io/tags/https/"}]},{"title":"试验田","slug":"experimental-field","date":"2016-04-26T19:20:00.000Z","updated":"2019-10-26T21:49:24.160Z","comments":true,"path":"2016/04/27/experimental-field/","link":"","permalink":"https://zh-h.github.io/2016/04/27/experimental-field/","excerpt":"","text":"Spring abc sring abc Java 编写的论坛社区，基于最新的 Spring 框架，包括 Spring Data JPA 和 Spring MVC 等 hacpai-sync-wordpress hacpai-sync-wordpress wordpress同步插件，同步您的博客内容到黑客派社区","categories":[],"tags":[]},{"title":"PHP7 的响应速度是旧版本的 230%!","slug":"24","date":"2016-04-26T05:01:00.000Z","updated":"2019-10-26T21:49:24.155Z","comments":true,"path":"2016/04/26/24/","link":"","permalink":"https://zh-h.github.io/2016/04/26/24/","excerpt":"","text":"Unbelievable!","categories":[{"name":"PHP","slug":"PHP","permalink":"https://zh-h.github.io/categories/PHP/"}],"tags":[]},{"title":"PHP7 + Nginx installation and optimization on Ubuntu","slug":"23","date":"2016-04-26T04:16:00.000Z","updated":"2019-10-26T21:49:24.155Z","comments":true,"path":"2016/04/26/23/","link":"","permalink":"https://zh-h.github.io/2016/04/26/23/","excerpt":"","text":"1. 安装 Nginx1. 使用源123sudo add-apt-repository ppa:nginx/stable sudo apt-get update sudo apt-get upgrade nginx -y 2. 安装1sudo yum install nginx 3. 配置然后配置站点12345678910111213141516171819202122232425262728293031server &#123; listen 80 ; listen [::]:80 ipv6only=on; root /usr/share/nginx/html/typecho; index index.php index.html index.htm; server_name applehater.cn; location / &#123; #if (-f $request_filename/index.html)&#123; # rewrite (.*) $1/index.html break; #&#125; #if (-f $request_filename/index.php)&#123; # rewrite (.*) $1/index.php; #&#125; #if (!-f $request_filename)&#123; # rewrite (.*) /index.php; #&#125; try_files $uri $uri/ /index.php?$query_string; &#125; location ~ \\.php$ &#123; try_files $uri /index.php =404; fastcgi_split_path_info ^(.+\\.php)(/.+)$; fastcgi_pass unix:/var/run/php/php7.0-fpm.sock; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125;&#125; 2. 安装 PHP71. 添加源12345$ sudo apt-get install python-software-properties software-properties-common$ sudo add-apt-repository ppa:ondrej/php$ sudo apt-get update 2. 安装 PHP7 和常用的扩展1$ sudo apt-get install php7.0-fpm php7.0-mysql php7.0-common php7.0-curl php7.0-cli php7.0-mcrypt php7.0-mbstring php7.0-dom 3. 配置 PHP7去掉路径前缀，编辑/etc/php/7.0/fpm/php.ini1cgi.fix_pathinfo=0 启动服务123sudo phpenmod mcryptsudo service php7.0-fpm restart 3. 测试1. 使用cli123456php -vPHP 7.0.5-3+donate.sury.org~trusty+1 (cli) ( NTS )Copyright (c) 1997-2016 The PHP GroupZend Engine v3.0.0, Copyright (c) 1998-2016 Zend Technologies with Zend OPcache v7.0.6-dev, Copyright (c) 1999-2016, by Zend Technologies 2. 使用 phpinfo创建文件/usr/share/nginx/html/typecho/info.php123&lt;?phpecho phpinfo();?&gt; 显示详细信息页面 3. ab 对比这是php5.61234567891011121314151617181920212223242526272829303132333435Server Software: nginx/1.8.1Server Hostname: applehater.cnServer Port: 80Document Path: /Document Length: 11494 bytesConcurrency Level: 1Time taken for tests: 3.321 secondsComplete requests: 100Failed requests: 0Total transferred: 1171500 bytesHTML transferred: 1149400 bytesRequests per second: 30.11 [#/sec] (mean)Time per request: 33.207 [ms] (mean)Time per request: 33.207 [ms] (mean, across all concurrent requests)Transfer rate: 344.52 [Kbytes/sec] receivedConnection Times (ms) min mean[+/-sd] median maxConnect: 0 0 0.0 0 0Processing: 30 33 1.9 33 39Waiting: 28 32 1.9 32 38Total: 30 33 2.0 33 39Percentage of the requests served within a certain time (ms) 50% 33 66% 33 75% 34 80% 35 90% 36 95% 38 98% 39 99% 39 100% 39 (longest request) 更新到 php7 后1234567891011121314151617181920212223242526272829303132333435Server Software: nginx/1.8.1Server Hostname: applehater.cnServer Port: 80Document Path: /Document Length: 11434 bytesConcurrency Level: 1Time taken for tests: 1.442 secondsComplete requests: 100Failed requests: 0Total transferred: 1161800 bytesHTML transferred: 1143400 bytesRequests per second: 69.34 [#/sec] (mean)Time per request: 14.421 [ms] (mean)Time per request: 14.421 [ms] (mean, across all concurrent requests)Transfer rate: 786.73 [Kbytes/sec] receivedConnection Times (ms) min mean[+/-sd] median maxConnect: 0 0 0.0 0 0Processing: 13 14 1.3 14 22Waiting: 13 14 1.1 14 22Total: 13 14 1.3 14 22Percentage of the requests served within a certain time (ms) 50% 14 66% 14 75% 15 80% 15 90% 15 95% 17 98% 20 99% 22 100% 22 (longest request) 可见升级之后qps提高了130%，请求时间从33.207 ms下降到14.421 ms 减少了130% ！","categories":[{"name":"PHP","slug":"PHP","permalink":"https://zh-h.github.io/categories/PHP/"},{"name":"调优","slug":"PHP/调优","permalink":"https://zh-h.github.io/categories/PHP/调优/"},{"name":"配置","slug":"PHP/调优/配置","permalink":"https://zh-h.github.io/categories/PHP/调优/配置/"}],"tags":[]},{"title":"欢迎使用 Typecho","slug":"start","date":"2016-04-25T05:19:36.000Z","updated":"2019-10-26T21:49:24.160Z","comments":true,"path":"2016/04/25/start/","link":"","permalink":"https://zh-h.github.io/2016/04/25/start/","excerpt":"","text":"如果您看到这篇文章,表示您的 blog 已经安装成功.","categories":[{"name":"默认分类","slug":"默认分类","permalink":"https://zh-h.github.io/categories/默认分类/"}],"tags":[]},{"title":"Django 之奇技淫巧 View","slug":"5","date":"2016-04-21T06:16:00.000Z","updated":"2019-10-26T21:49:24.157Z","comments":true,"path":"2016/04/21/5/","link":"","permalink":"https://zh-h.github.io/2016/04/21/5/","excerpt":"","text":"Django View1. HttpResponsehttp.py def _read_file(file_name, buffer_size): f = open(file_name, &quot;rb&quot;) while True: c = f.read(buffer_size) if c: yield c else: break f.close() def down_file(file_name, download_file_name=&apos;download.file&apos;, content_type=&apos;APPLICATION/OCTET-STREAM&apos;, buffer_size=1024): response = HttpResponse(_read_file(file_name, buffer_size), content_type=content_type); response[&apos;Content-Type&apos;] = &apos;application/octet-stream; charset=utf-8&apos; response[&apos;Content-Disposition&apos;] = &apos;attachment; filename={0}&apos;.format(download_file_name) return response views.py def out_odt(requesest,name): template = webodt.ODFTemplate(&apos;test.odt&apos;) context = dict(name=name) document = template.render(Context(context)) base_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) output_path = os.path.join(base_path,&apos;_webodt&apos;,&apos;outputs&apos;,&apos;out.odt&apos;) with open(output_path,&apos;w&apos;) as f: f.write(document.read()) f.close() return down_file(output_path) 下载文件,自定义返回类型没办法用中文名，等待hack response[&apos;Content-Disposition&apos;] = &apos;attachment; filename={0}&apos;.format(download_file_name.encode(&apos;UTF-8&apos;)) 把download_file_name进行urlencode只在个别浏览器起效","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://zh-h.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://zh-h.github.io/tags/django/"},{"name":"Django","slug":"Django","permalink":"https://zh-h.github.io/tags/Django/"},{"name":"Python","slug":"Python","permalink":"https://zh-h.github.io/tags/Python/"}]},{"title":"Django 之奇技淫巧 Admin","slug":"4","date":"2016-04-21T06:14:00.000Z","updated":"2019-10-26T21:49:24.156Z","comments":true,"path":"2016/04/21/4/","link":"","permalink":"https://zh-h.github.io/2016/04/21/4/","excerpt":"","text":"Django Admin Site1. 自定后台管理面板列表显示的返回值class ThesisTopicReviewHistoryAdmin(admin.ModelAdmin): list_display = (&apos;reviewer&apos;, &apos;thesisTopic&apos;, &apos;comment&apos;, &apos;state&apos;, ) list_filter = (&apos;state&apos;, &apos;reviewer&apos;, &apos;created&apos;, ) search_fields = (&apos;thesisTopic&apos;,) def save_model(self, request, obj, form, change): # 保存该评审记录 obj.save() # 改变相应题目的评审状态 topic = obj.thesisTopic topic.reviewState = obj.state topic.save() def get_readonly_fields(self, request, obj=None): if request.user.is_superuser: return () else: return self.list_display 以上类如get_attrbute_fields()的方法均可以重写。如果需要让一个timestamp类型的create_at属性不是显示整数二十显示一个完整的日期，可以重写此方法. class TeacherReviewAdmin(admin.ModelAdmin): list_display = (&apos;get_topic&apos;, &apos;student&apos;, &apos;comment&apos;, &apos;score&apos;,&apos;create_at&apos;,&apos;get_year&apos;, &apos;review_state&apos;,) list_filter = (&apos;student__year&apos;, &apos;student__studentClass&apos;, &apos;student__studentClass__campus&apos;) search_fields = (&apos;student__name&apos;, &apos;student__studentNo&apos;) teacher_readonly_fields = (&apos;student&apos;, &apos;topic&apos;, &apos;finalthesisdoc&apos;,) teacher_readonly_fields_no_topic = (&apos;student&apos;, &apos;topic&apos;, &apos;finalthesisdoc&apos;, &apos;comment&apos;, &apos;score&apos;, &apos;review_state&apos;,) superuser_readonly_fields = (&apos;topic&apos;, &apos;finalthesisdoc&apos;,) superuser_fields = (&apos;student&apos;, &apos;topic&apos;, &apos;finalthesisdoc&apos;, &apos;comment&apos;, &apos;score&apos;, &apos;review_state&apos;,) teacher_fields = (&apos;student&apos;, &apos;topic&apos;, &apos;finalthesisdoc&apos;, &apos;comment&apos;, &apos;score&apos;, &apos;review_state&apos;,) def get_year(self, obj): return obj.student.year # 甚至可以动态更改属性的描述 get_year.short_description = u&apos;年份&apos; get_year.admin_order_field = &apos;-student__year&apos; def create_at(self, obj=None): return datetime.datetime.fromtimestamp(obj.create_at) 2. 自定义列表字段html标签返回class WeiboUserAdmin(admin.ModelAdmin): def expires_time(self, obj): return datetime.datetime.fromtimestamp(obj.expires_at) expires_time.short_description = u&apos;授权过期时间&apos; def refresh(self,obj): btn_str = &apos;&lt;a class=&quot;btn btn-xs btn-danger&quot; href=&quot;{}&quot;&gt;{}&lt;/a&gt;&apos; return format_html(btn_str,&apos;http://www.google.com&apos;,obj.uid) refresh.short_description = u&apos;更新授权&apos; # 注意要记得把这个方法放到现实列表里 list_display = (&apos;nick&apos;,&apos;uid&apos;,&apos;access_token&apos;,&apos;expires_time&apos;,&apos;refresh&apos;) 1459653892756 这样你的表单上就会出现列按钮，同样的，你可以为此定义一个显示头像的方法 3. 下拉框列表过滤def formfield_for_foreignkey(self, db_field, request=None, **kwargs): # 是超级管理员就全部跳过 if request.user.is_superuser: pass # 不是超级管理员并且字段符合的话，就进行过滤 elif db_field.name == &apos;official&apos;: kwargs[&apos;queryset&apos;] = Official.objects.filter(user=request.user) return super(FilterAdmin, self).formfield_for_foreignkey(db_field, request=None, **kwargs) 下拉框过滤 1459746103458 竟然全部都是动态的字段，感觉很不安全啊","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://zh-h.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://zh-h.github.io/tags/django/"},{"name":"Django","slug":"Django","permalink":"https://zh-h.github.io/tags/Django/"},{"name":"Python","slug":"Python","permalink":"https://zh-h.github.io/tags/Python/"}]},{"title":"Django 部署 uWSGI or Gunicorn + Nginx + Supervisor","slug":"6","date":"2016-04-14T06:16:00.000Z","updated":"2019-10-26T21:49:24.158Z","comments":true,"path":"2016/04/14/6/","link":"","permalink":"https://zh-h.github.io/2016/04/14/6/","excerpt":"","text":"附上对比 来源UWSGI VS. GUNICORN, OR HOW TO MAKE PYTHON GO FASTER THAN NODE 使用pip镜像编辑 ~/.pip/pip.conf [global] index-url=https://pypi.tuna.tsinghua.edu.cn/simple/ *windows* 编辑 %APPDATA%\\pip\\pip.ini [global] timeout = 6000 index-url = http://pypi.douban.com/simple trusted-host = pypi.douban.com 更新依赖pip install uwsgi 编辑配置文件 uwsgi.ini[uwsgi] # Django-related settings chdir = /home/zonghua/Documents/test_project module = test_project.wsgi:application env = DJANGO_SETTINGS_MODULE=test_project.settings_production home = /home/zonghua/Documents/test_project/venv reload-mercy = 10 user = zonghua uid = zonghua pcre-jit thunder-lock enable-threads master = True threads = 2 processes = 4 socket = 127.0.0.1:8001 chmod-socket = 664 vacuum = true 执行命令uwsgi --ini uwsgi.ini 运行情况[uWSGI] getting INI configuration from /home/zonghua/Documents/test_project/uwsgi.ini *** Starting uWSGI 2.0.12 (64bit) on [Tue Apr 5 13:59:02 2016] *** compiled with version: 5.2.1 20151010 on 04 April 2016 01:12:07 os: Linux-4.2.0-34-generic #39-Ubuntu SMP Thu Mar 10 22:13:01 UTC 2016 nodename: x machine: x86_64 clock source: unix pcre jit enabled detected number of CPU cores: 4 current working directory: /home/zonghua/Documents/test_project detected binary path: /home/zonghua/Documents/test_project/venv/bin/uwsgi chdir() to /home/zonghua/Documents/test_project your processes number limit is 11829 your memory page size is 4096 bytes detected max file descriptor number: 1024 lock engine: pthread robust mutexes thunder lock: enabled uwsgi socket 0 bound to TCP address 127.0.0.1:8001 fd 3 Python version: 2.7.10 (default, Oct 14 2015, 16:09:02) [GCC 5.2.1 20151010] Set PythonHome to /home/zonghua/Documents/test_project/venv Python main interpreter initialized at 0x93b180 python threads support enabled your server socket listen backlog is limited to 100 connections your mercy for graceful operations on workers is 60 seconds mapped 415360 bytes (405 KB) for 8 cores *** Operational MODE: preforking+threaded *** WSGI app 0 (mountpoint=&apos;&apos;) ready in 1 seconds on interpreter 0x93b180 pid: 2781 (default app) *** uWSGI is running in multiple interpreter mode *** spawned uWSGI master process (pid: 2781) spawned uWSGI worker 1 (pid: 2784, cores: 2) spawned uWSGI worker 2 (pid: 2785, cores: 2) spawned uWSGI worker 3 (pid: 2787, cores: 2) spawned uWSGI worker 4 (pid: 2789, cores: 2) uWSGI 文档 nginx 配置 文件 /etc/nginx/site-avaiable/testserver { listen 80; charset utf-8; client_max_body_size 75M; location /media { alias /path/to/project/media; } location /static { alias /path/to/project/static; } location / { uwsgi_pass 127.0.0.1:8001; include uwsgi_params; } } supervisor 配置文件 /etc/supervisor/supervisor.conf使用 uwsgi[program:test] directory= /home/zonghua/Documents/test_project command = /home/zonghua/Documents/test_project/venv/bin/uwsgi --ini /home/zonghua/Documents/test_project/uwsgi.ini user = zonghua autostart = true autorestart = true stopsignal = QUIT redirect_stderr = true loglevel = error stdout_logfile = /home/zonghua/Documents/test_project/logs/uwsgi_out.log stderr_logfile = /home/zonghua/Documents/test_project/logs/uwsgi_err.log logfile_maxbytes = 1M 使用 gunicorn1234567891011directory= /home/py/www/thesiscommand = gunicorn thesis_mis.wsgi --workers 6 --bind 0.0.0.0:8001 --env DJANGO_SETTINGS_MODULE=thesis_mis.settings_productionuser = liautostart = trueautorestart = truestopsignal = QUITredirect_stderr = trueloglevel = errorstdout_logfile = /home/py/www/uwsgi_out.logstderr_logfile = /home/py/www/uwsgi_err.loglogfile_maxbytes = 1M 查看状态1supervisorctl status all 启动1supervisorctl [start|stop|restart|status] test Supervisor 文档","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://zh-h.github.io/tags/nginx/"},{"name":"python","slug":"python","permalink":"https://zh-h.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://zh-h.github.io/tags/django/"},{"name":"Django","slug":"Django","permalink":"https://zh-h.github.io/tags/Django/"},{"name":"Python","slug":"Python","permalink":"https://zh-h.github.io/tags/Python/"},{"name":"supervisor","slug":"supervisor","permalink":"https://zh-h.github.io/tags/supervisor/"},{"name":"uwsgi","slug":"uwsgi","permalink":"https://zh-h.github.io/tags/uwsgi/"}]},{"title":"Django 之奇技淫巧 Model","slug":"3","date":"2016-03-29T06:13:00.000Z","updated":"2019-10-26T21:49:24.155Z","comments":true,"path":"2016/03/29/3/","link":"","permalink":"https://zh-h.github.io/2016/03/29/3/","excerpt":"","text":"Django Model1. RuntimeWarning: DateTimeField received a naive datetimeUSE_TZ = False 禁用掉时区设置，通通使用系统时间，所以要保证设置了正确的系统时间 TIME_ZONE = ‘Asia/Shanghai如果启用了时区设置，可以设置应用独立的时间 2. 级联删除wechat_user = models.ForeignKey(Wechat_User,verbose_name=u&apos;微信&apos;,blank=True,null=True,on_delete=models.SET_NULL) CASCADE: 默认级联删除PROTECT: 通过抛出django.db.models.ProtectedErrordjango.db.models.ProtectedError错误来阻止删除关联的对象SET_NULL: 前置条件需要设定null=True，设置ForeignKey 为 NullSET_DEFAULT: 前置条件需要先设定默认值，设置 ForeignKey 为默认值SET: 设置为某个方法返回的值DO_NOTHING: 保留原样，如果再次把外键的对象添加回来，会再次显示。如果数据库设置必须关联则会报IntegrityError错。 ||13 ||哈哈哈哈哈 ||2016-04-02 23:50:51 ||2 || 1|| || 14 ||哈哈哈哈哈哈 || 2016-04-02 23:56:19 ||2 || 1|| ||15 ||恍恍惚惚恍恍惚惚机会 ||2016-04-03 11:47:21 ||2 || 上表中13 14 是设定了DO_NOTHING；15 是设定了SET_NULL 3. 关联查询models.py class School(models.Model): name = models.CharField(max_length=30, verbose_name=&apos;school&apos;) class Deparment(models.Model): name = models.CharField(max_length=30, verbose_name=&apos;department&apos;) school = models.ForeignKey(School, verbose_name=&apos;school&apos;) class StudentClass(models.Model): name = models.CharField(max_length=30, verbose_name=&apos;class&apos;) department = models.ForeignKey(Deparment, verbose_name=&apos;department&apos;) class StudentYear(models.Model): year = models.CharField(max_length=30, verbose_name=&apos;year&apos;) class Student(models.Model): name = models.CharField(max_length=30, verbose_name=&apos;student&apos;) studentClass = models.ForeignKey(StudentClass, verbose_name=&apos;class&apos;) year = models.ForeignKey(StudentYear, verbose_name=&apos;year&apos;) 查询的使用用双下划线去关联外键属性，只能过滤id的值 &gt;&gt;&gt;school_ids = School.objects.filter(name=&apos;EE&apos;).values(&apos;id&apos;) &gt;&gt;&gt;year_ids = StudentYear.objects.filter(year=&apos;2016&apos;).values(&apos;id&apos;) &gt;&gt;&gt;student = Student.objects.filter(studentClass__department__school_id__in=school_ids, year_id__in=year_ids).first() &lt;Student object&gt; 查询是懒惰的，只会在最终序列的时候执行拼接后的语句 utils-89 DEBUG : (0.001) QUERY","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://zh-h.github.io/tags/python/"},{"name":"django","slug":"django","permalink":"https://zh-h.github.io/tags/django/"},{"name":"Django","slug":"Django","permalink":"https://zh-h.github.io/tags/Django/"},{"name":"Python","slug":"Python","permalink":"https://zh-h.github.io/tags/Python/"}]},{"title":"Hacpai Sync Wordpress 插件","slug":"7","date":"2016-03-12T06:21:00.000Z","updated":"2019-10-26T21:49:24.158Z","comments":true,"path":"2016/03/12/7/","link":"","permalink":"https://zh-h.github.io/2016/03/12/7/","excerpt":"","text":"给个星吧Github Hacpai Sync Wordpress 下载hacpai-sync-wordpress-v1-20.zip 试用wordpress.applehater.cn add_action(&apos;template_redirect&apos;, &apos;sync_comment&apos;);//通过这个方法拦截Http请求 function sync_comment() { if ($_GET[&apos;hacpai-api&apos;] === &apos;sync-comment&apos;){ $data = json_decode(file_get_contents(&quot;php://input&quot;));//可以获取任意的请求正文 // something } } 1457774925706 2016/3/13 0:30 更新 v 0.8 完成了黑客派同步到博客的功能； 移除了没用的东西； 还没有找到配置面板的文档应该怎么做。 2016/3/13 15:30 更新 v 1.0 增加了配置面板 修复了新建文章自动生成草稿当成更新文章的错误 2016/4/11 更新 v 1.10 社区评论同步到博客内容，改为$comment-&gt;contentHTML 社区评论同步到博客记录原始IP 移除同步分类选项,细分同步选项 2016/4/11 更新 v 1.20 记录日志到文件 配置面板显示日志 1460365288892","categories":[{"name":"PHP","slug":"PHP","permalink":"https://zh-h.github.io/categories/PHP/"},{"name":"wordpress","slug":"PHP/wordpress","permalink":"https://zh-h.github.io/categories/PHP/wordpress/"},{"name":"php","slug":"PHP/wordpress/php","permalink":"https://zh-h.github.io/categories/PHP/wordpress/php/"},{"name":"wordpress","slug":"PHP/wordpress/php/wordpress","permalink":"https://zh-h.github.io/categories/PHP/wordpress/php/wordpress/"}],"tags":[]},{"title":"微博SDK Going to buffer response body of large or unknown size. Using getResponseBodyAsStream instead is recommend","slug":"11","date":"2016-02-08T06:37:00.000Z","updated":"2019-10-26T21:49:24.150Z","comments":true,"path":"2016/02/08/11/","link":"","permalink":"https://zh-h.github.io/2016/02/08/11/","excerpt":"","text":"微博提供Java版本的SDK竟然是Beta版weibo4j-oauth2-beta3.1.1 运行示例的时候出现了这样的警告： 1Going to buffer response body of large or unknown size. Using getResponseBodyAsStream instead is recommend 检索代码出现在weibo4j.http.HttpClient.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public Response httpRequest(HttpMethod method, Boolean WithTokenHeader, String token) throws WeiboException &#123; InetAddress ipaddr; int responseCode = -1; try &#123; ipaddr = InetAddress.getLocalHost(); List&lt;Header&gt; headers = new ArrayList&lt;Header&gt;(); if (WithTokenHeader) &#123; if (token == null) &#123; throw new IllegalStateException(&quot;Oauth2 token is not set!&quot;); &#125; headers.add(new Header(&quot;Authorization&quot;, &quot;OAuth2 &quot; + token)); headers.add(new Header(&quot;API-RemoteIP&quot;, ipaddr.getHostAddress())); client.getHostConfiguration().getParams() .setParameter(&quot;http.default-headers&quot;, headers); for (Header hd : headers) &#123; log(hd.getName() + &quot;: &quot; + hd.getValue()); &#125; &#125; method.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, new DefaultHttpMethodRetryHandler(3, false)); client.executeMethod(method); Header[] resHeader = method.getResponseHeaders(); responseCode = method.getStatusCode(); log(&quot;Response:&quot;); log(&quot;https StatusCode:&quot; + String.valueOf(responseCode)); for (Header header : resHeader) &#123; log(header.getName() + &quot;:&quot; + header.getValue()); &#125; Response response = new Response(); response.setResponseAsString(method.getResponseBodyAsString()); response.setResponseAsString(stringBuffer.toString()); log(response.toString() + &quot;\\n&quot;); if (responseCode != OK) &#123; try &#123; throw new WeiboException(getCause(responseCode), response.asJSONObject(), method.getStatusCode()); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125; &#125; return response; &#125; catch (IOException ioe) &#123; throw new WeiboException(ioe.getMessage(), ioe, responseCode); &#125; finally &#123; method.releaseConnection(); &#125;&#125;``` 原因就是没有字符缓冲，可能因为响应字符过长，而影响效率， 因此从第396行改为： // old code response.setResponseAsString(method.getResponseBodyAsString()); InputStream inputStream = method.getResponseBodyAsStream(); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); StringBuffer stringBuffer = new StringBuffer(); String temp ; while ((temp=bufferedReader.readLine())!=null){ stringBuffer.append(temp); } response.setResponseAsString(stringBuffer.toString()); ```","categories":[{"name":"Java","slug":"Java","permalink":"https://zh-h.github.io/categories/Java/"},{"name":"微博sdk","slug":"Java/微博sdk","permalink":"https://zh-h.github.io/categories/Java/微博sdk/"}],"tags":[]},{"title":"node get post提交中文参数","slug":"9","date":"2015-10-04T06:34:00.000Z","updated":"2019-10-26T21:49:24.160Z","comments":true,"path":"2015/10/04/9/","link":"","permalink":"https://zh-h.github.io/2015/10/04/9/","excerpt":"","text":"由于历史遗留,不少网络服务使用的是gbk编码,当前需要对某站点模拟post提交含有中文的参数,却因为node默认仅仅支持UTF-8编码,经过urlEncode的字符会有偏差,与目标字符并不对应. 常见字符编码 iso8859-1 最多能表示的字符范围是0-255，应用于英文系列。比如，字母a的编码为0x61=97，iso8859-1编码表示的字符范围很窄，无法表示中文字符。但是，由于是单字节编码，和计算机最基础的表示单位一致，所以很多时候，仍旧使用iso8859-1编码来表示。而且在很多协议上，默认使用该编码。 GB2312/GBK 汉字的国标码(GB拼音’国标’首字母)，专门用来表示汉字，是双字节编码，而英文字母和iso8859-1一致（兼容iso8859-1编码）。其中gbk是微软公司对此的扩展,此编码能够用来同时表示繁体字和简体字，而gb2312只能表示简体字，gbk兼容gb2312编码. unicode 统一的编码,可以用来表示各国文字的字符，是定长双字节或者四字节编码，包括英文字母在内。定长编码便于计算机处理（注意GB2312/GBK不是定长编码），而unicode又可以用来表示所有字符，所以在很多软件内部是使用unicode编码来处理的，比如java,javascript也是同样的,不难料,unicode可以支持emoji,所以甚至可以用表情字符来编程. UTF 因为unicode编码不兼容iso8859-1编码，因为对于英文字母，unicode也需要两个字节来表,所以很浪费空间。nicode不便于传输和存储,由此产生了utf编码，utf编码兼容iso8859-1编码，同时也可以用来表示所有语言的字符 utf编码是不定长编码，每一个字符的长度从1-6个字节不等。一般来讲，英文字母都是用一个字节表示，而汉字使用三个字节。 urlEncode 为什么要使用它 一产品名称为A&amp;T Plastic,在产品列表中就产生了这样的一个联接&lt;a href=”product.asp?name=A&amp;T Plastic”&gt;A&amp;T Plastic&lt;/a&gt; 在服务器端接收此参数的时候怎么也无法接收到准确的产品名。 当时就问我，如何解决，也许是当时忙吧，随口告诉他用HTMLENCODE方法，对方试告诉并没有能解决这个问题。我当时没有再给予回答，偶尔想起实在是对不起，我讲错了。今日闲暇就整理了一下如何处理GET方式提交的含有特殊字符的参数，以表内心的愧疚。 特殊特殊字符的含义 # 用来标志特定的文档位置 %23 % 对特殊字符进行编码 %25 &amp; 分隔不同的变量值对 %26 + 在变量值中表示空格 %2B / 表示目录路径 %2F = 用来连接键和值 %3D ? 表示查询字符串的开始 %3F 当键值中含有以上列表中的一些字符时就无法准确的接收其中的值,urlEncode就像源码中\\一样起到了转义的作用,使得各方面语义不再混淆 EncType 是html中form元素的属性,常用的有application/x-www-form-urlencoded和multipart/form-data,默认使用前者. 使用application/x-www-form-urlencoded会将表单数据进行urlEncode,即使它不是get请求,会将表单的键值对拼接成get请求的query一样.并且urlEnocde和服务端的urlDecode(urlEncode的反处理)是配对的,不能一方面修改属性,否则参数将无法正确获取. Buffer node支持的字符编码 ‘ascii’ -仅用于7位的ASCII数据。这种编码方法非常快速，并且一旦设置便会抛弃高位数据。注意，这个编码方式会将空字符（’\\0’ 或 ‘\\u0000’）转换成0x20（空格的字符编码）。如果想把空字符转换成0x00，得使用’utf8’。 ‘utf8’ -多字节编码的Unicode字符。许多网页以及其它文档格式会使用UTF-8编码。 ‘ucs2’ -仅用2个字节编码的Unicode字符。它仅可对BMP（基本多文种平面或第零平面，从U+0000到U+FFFF）进行编码。 ‘base64’ - Base64字符串编码。 ‘binary’ -经使用每个字符的头8位把原始二进制数据编码成字符串的一种途径。这是一个已经被废弃的编码方法。 且为了能让缓冲器对象取代这个编码方法，应避免使用它。在Node的未来版本中也会移除掉这个编码方法。 ‘hex’ - 把每个字节编码成两个十六进制字符。 Buffer类 Javascript对于字符串(String)的操作比较擅长而且友好的，但是在Node中，还需要处理网络流，文件等二进制数据，对于处理这些二进制数据，javascript自有的字符串操作机制就不能满足这些需求，所以Buffer的出现就是为了解决这个问题。 Buffer类似一个数组,为两位数的16进制数,即(0-255)范围，Buffer内存的申请是在V8引擎堆外,是一个javascript与C++结合的一个模块. new Buffer(str, [encoding]);//按照指定编码 buf.toString([encoding]);//返回解码的字符串 ` 注意Buffer的拼接 国外使用英文编码,对于一下读取文本内容的示例代码是没有任何问题. var fs = require('fs'); var rs = fs.createReadStream('testdata.md'); var data = ''; rs.on(\"data\", function (trunk){ data += trunk; }); rs.on(\"end\", function () { console.log(data); }); 如果用来读取中文就可能出现问题,在上面代码中 //data += trunk 隐藏了隐性转换 data = data.toString() + trunk.toString(); 按照单个字节去拼接字串就会出现乱码问题. 以下是一个正确的代码示例. var buffers = []; var nread = 0; readStream.on('data', function (chunk) { buffers.push(chunk); nread += chunk.length; }); readStream.on('end', function () { var buffer = null; switch(buffers.length) { case 0: buffer = new Buffer(0); break; case 1: buffer = buffers[0]; break; default: buffer = new Buffer(nread); for (var i = 0, pos = 0, l = buffers.length; i &lt; l; i++) { var chunk = buffers[i]; chunk.copy(buffer, pos); pos += chunk.length; } break; } }); 如果是非UTF-8编码,可以在readStream.on('end',function (){//})里面使用第三方包进行解码. 试探 在线的urlEncode服务,中文会,会按照16位字节呈现,然后加以%进行链接 蛤 //GBK编码字符经过urlEncode %B8%F2 ///UTF-8编码字符经过urlEncode %E8%9B%A4 node端使用iconv-lite这个库进行gbk编码的字符串处理,可以方便得对各种编码字符与字节串进行相互转换. var iconv = require('iconv-lite'); var word = '蛤', word_gbk = iconv.encode(word,'gbk'), word_unicode = iconv.encode(word,'utf8'); console.log(word_gbk,word_unicode) 执行这段代码之后输出结果如下 &lt;Buffer b8 f2&gt; &lt;Buffer e8 9b a4&gt; 对比两个输出结果可见urlEncode的处理过程. 使用node api http.request(options[, callback]) 用来产生若干的http request请求,option是一个有键值的对象,或者是一个字符串.但是字符串必须是按照urlEncode,使用 url.parse()进行处理后,或者符合对应的规范. Options: host: A domain name or IP address of the server to issue the request to. Defaults to 'localhost'. hostname: To support url.parse() hostname is preferred over host port: Port of remote server. Defaults to 80. localAddress: Local interface to bind for network connections. socketPath: Unix Domain Socket (use one of host:port or socketPath) method: A string specifying the HTTP request method. Defaults to 'GET'. path: Request path. Defaults to '/'. Should include query string if any. E.G. '/index.html?page=12'. An exception is thrown when the request path contains illegal characters. Currently, only spaces are rejected but that may change in the future. headers: An object containing request headers. auth: Basic authentication i.e. 'user:password' to compute an Authorization header. keepAlive: {Boolean} Keep sockets around in a pool to be used by other requests in the future. Default = false keepAliveMsecs: {Integer} When using HTTP KeepAlive, how often to send TCP KeepAlive packets over sockets being kept alive. Default = 1000. Only relevant if keepAlive is set to true. agent: Controls Agent behavior. When an Agent is used request will default to Connection: keep-alive. Possible values: undefined (default): use global Agent for this host and port. Agent object: explicitly use the passed in Agent. false: opts out of connection pooling with an Agent, defaults request to Connection: close. 详细说明请参考官方文档http.request(options[, callback]) 模拟客户端 先用java编写我们需要的客户端index.jsp.默认使用的是UTF-8编码. &lt;%=request.getParameter(\"msg\")%&gt; &nbsp; 按照文档一个简单demo // 表单 var postData = querystring.stringify({ 'msg' : '蛤' }); var options = { hostname: 'localhost', port: 8080, path: '/test/', method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded', 'Content-Length': postData.length } }; var req = http.request(options, function(res) { console.log('STATUS: ' + res.statusCode+'\\n'); console.log('HEADERS: ' + JSON.stringify(res.headers)+'\\n'); res.setEncoding('binary'); res.on('data', function (chunk) { console.log('BODY: ' + chunk+'\\n'); }); }); req.on('error', function(e) { console.log('problem with request: ' + e.message); }); // 经过urlEncode的表单,使用UTF-8编码 console.log(postData+'\\n'); // write data to request body req.write(postData); req.end(); 执行结果 msg=%E8%9B%A4 STATUS: 200 HEADERS: {\"server\":\"Apache-Coyote/1.1\",\"set-cookie\":[\"JSESSIONID=1E4CE1F397021A0EF08A1062470DEA33; Path=/test/; HttpOnly\"],\"content-type\":\"text/html;charset=ISO-8859-1\",\"content-length\":\"3\",\"date\":\"Mon, 31 Aug 2015 14:59:09 GMT\",\"connection\":\"close\"} BODY: 蛤 如果在服务器端,将接收的的参数当做GBK编码处理,修改index.jsp &lt;%@ page contentType=\"text/html;charset=GBK\"%&gt; //页面显示编码 &lt;% response.setContentType(\"text/html;charset=GBK\");//页面输出参数编码 request.setCharacterEncoding(\"GBK\");//获取请求参数编码 String msg=request.getParameter(\"msg\"); out.write(msg+\"source: 蛤\"); %&gt; 用UTF-8请求,返回的结果就会出现乱码 msg=%E8%9B%A4 STATUS: 200 HEADERS: {\"server\":\"Apache-Coyote/1.1\",\"set-cookie\":[\"JSESSIONID=84E9501059367C18376212007C47FE8D; Path=/test/; HttpOnly\"],\"content-type\":\"text/html;charset=GBK\",\"content-length\":\"6\",\"date\":\"Mon, 31 Aug 2015 15:16:25 GMT\",\"connection\":\"close\"} BODY: ???? BODY: ? 貌似jsp输出的字符编码并不是GBK的,对编码设置无用? JSP的编码巨坑 Tomcat容器默认的编码会将接收的参数进行ISO-8859-1解码!!即使你声明了一大堆GBK,编码还是会错乱,解决办法是将字符按照ISO-8859-1解码回去,再用GBK编码.由此我们的index.jsp修改成这个样子. &lt;%@ page language=\"java\" contentType=\"text/html; charset=GBK\" pageEncoding=\"GBK\"%&gt; &lt;!DOCTYPE&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;GBK page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;GBK编码:&lt;/p&gt; &lt;% if (request.getParameter(\"msg\")!=null){ %&gt; &lt;span&gt;&lt;%= new String( request.getParameter(\"msg\").getBytes(\"ISO-8859-1\"),\"GBK\") %&gt;&lt;/span&gt; &lt;% } %&gt; &lt;/body&gt; &lt;/html&gt; 正确显示的GBK编码的网页 接下来我们使用rest-client对这个测试页面提交请求 方法选择POST,提交选项为原样字符,内容类型同样为默认,其他默认 这里填入的字符是按照GBK进行了UrlEncode处理 服务器端正确按照编码处理,返回显示完整的结果 再看node api response.write(chunk[, encoding][, callback]) 如果这个方法被回调,但是response.writeHead()还没有被回调,它会切换到没有完成的header模式,然后强制刷入header. 它会发送请求主体,这个方法可能会调用多次去分块发送请求主体. 请求的数据块可能是一个字符串或者字节数组,如果数据块是一个字符串,会默认将字符串进行utf8编码然后发送,如果是字节数组就直接发送出去,数据全部发送后调用回调. 由此我们可以将经过目标编码的表单的字节数组写入达到目的. 但是试验发现node的api有坑!之前的的demo使用了querystring进行url编码,默认是按照UTF-8编码,node本来也不支持GBK. var postData = querystring.stringify({ 'msg' : '蛤' }); querystring.stringify(obj[, sep][, eq][, options]) 它介绍了一个gbk中文编码的组件,貌似可以达到目的. // Suppose gbkEncodeURIComponent function already exists, // it can encode string with `gbk` encoding querystring.stringify({ w: '中文', foo: 'bar' }, null, null, { encodeURIComponent: gbkEncodeURIComponent }) // returns 'w=%D6%D0%CE%C4&amp;foo=bar' 结果在node命令行模式执行的结果如下. &gt; var r = querystring.stringify({ w: '中文', foo: 'bar' }, null, null, ... { encodeURIComponent: gbkEncodeURIComponent }); ReferenceError: gbkEncodeURIComponent is not defined at repl:2:23 at REPLServer.defaultEval (repl.js:132:27) at bound (domain.js:254:14) at REPLServer.runBound [as eval] (domain.js:267:12) at REPLServer.&lt;anonymous&gt; (repl.js:279:12) at REPLServer.emit (events.js:107:17) at REPLServer.Interface._onLine (readline.js:214:10) at REPLServer.Interface._line (readline.js:553:8) at REPLServer.Interface._ttyWrite (readline.js:830:14) at ReadStream.onkeypress (readline.js:109:10) &gt; 嗯,gbkEncodeURIComponent并不是node内置的,是需要Options包含一个encodeURIComponent方法,默认的是使用querystring.escape. 现在查看node querystring模块的源码,这里是stringify方法段. //这里是判断类型,使得返回都是字符串 var stringifyPrimitive = function(v) { if (typeof v === 'string') return v; if (typeof v === 'number' &amp;&amp; isFinite(v)) return '' + v; if (typeof v === 'boolean') return v ? 'true' : 'false'; return ''; }; QueryString.stringify = QueryString.encode = function(obj, sep, eq, options) { sep = sep || '&amp;'; eq = eq || '='; var encode = QueryString.escape; if (options &amp;&amp; typeof options.encodeURIComponent === 'function') { encode = options.encodeURIComponent; } if (obj !== null &amp;&amp; typeof obj === 'object') { var keys = Object.keys(obj); var len = keys.length; var flast = len - 1; var fields = ''; for (var i = 0; i &lt; len; ++i) { var k = keys[i]; var v = obj[k]; var ks = encode(stringifyPrimitive(k)) + eq;//这里进行编码 if (Array.isArray(v)) { var vlen = v.length; var vlast = vlen - 1; for (var j = 0; j &lt; vlen; ++j) { fields += ks + encode(stringifyPrimitive(v[j])); if (j &lt; vlast) fields += sep; } if (vlen &amp;&amp; i &lt; flast) fields += sep; } else { fields += ks + encode(stringifyPrimitive(v)); if (i &lt; flast) fields += sep; } } return fields; } return ''; }; 完善urlEncode模块 javascript的数值与字符转换 &gt; escape('蛤');//转unicode '%u86E4' &gt; parseInt('86E4',16);//转16进制 34532 &gt; parseInt('1010',2);//转 10 &gt; parseInt('1010',2).toString(2);//必须强制转换为Int后调用用toString方法 '1010' 处理仅有的中文 Buffer是一个数组,循环拼接转换的字符. var gbk = iconv.encode('蛤','gbk'), i = 0, str=''; for (i;i&lt;gbk.length;i++){ str += '%' + gbk[i].toString(16); }; str = str.toUpperCase(); console.log(str); $ node app.js %B8%F2 结果与目标%B8%F2一致. 构造encodeURIComponent 其实很简单,2333.首先要看懂文档,并且要记在心里javascript方法也是对象,可以赋值引用. var postData = querystring.stringify({ w: '蛤', foo: 'bar' }, null, null, { encodeURIComponent: function (str){ var chinese = new RegExp(/[^\\x00-\\xff]/g); var gbkBuffer = null; var i = 0; var tempStr = ''; if (chinese.test(str)){//用正则判断它是不是中文字符 gbkBuffer = iconv.encode(str,'gbk');//进行gbk编码 for (i;i&lt;gbkBuffer.length;i++){ tempStr += '%' + gbkBuffer[i].toString(16);//拼接字符串 }; tempStr = tempStr.toUpperCase();//都转成大写 }else{ return querystring.escape(str);//否则使用默认的编码 } }}); console.log(postData); GBK和UTF-8编码的英文数字符都是一样的,因为都是基于iso8859-1,使用一个字节. w=%B8%F2&amp;foo=bar [Finished in 0.3s] 完成 var form = { msg:'蛤', psw:'2333' } var postData = querystring.stringify(form, null, null, { encodeURIComponent: function (str){ var chinese = new RegExp(/[^\\x00-\\xff]/g); var gbkBuffer = null; var i = 0; var tempStr = ''; if (chinese.test(str)){// gbkBuffer = iconv.encode(str,'gbk'); for (i;i&lt;gbkBuffer.length;i++){ tempStr += '%' + gbkBuffer[i].toString(16); }; tempStr = tempStr.toUpperCase(); return tempStr; }else{ return querystring.escape(str); } } }); var options = { hostname: 'localhost', port: 8080, path: '/test/', method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded', 'Content-Length': postData.length }//Cookie也是放在请求头里面 }; var req = http.request(options, function(res) { console.log('STATUS: ' + res.statusCode); //响应的Cookie在res.header['set-cookie'] console.log('HEADERS: ' + JSON.stringify(res.headers)); // res.setEncoding('binary');//接收参数的时候先不要解码 res.on('data', function (chunk) { console.log('BODY: ' + iconv.decode(chunk,'gbk'));//gbk解码 }); }); req.on('error', function(e) { console.log('problem with request: ' + e.message); }); // write data to request body req.write(postData); req.end(); 正确显示 STATUS: 200 HEADERS: {\"server\":\"Apache-Coyote/1.1\",\"set-cookie\":[\"JSESSIONID=8B8D1713441C8445C8B89720DA4FD019; Path=/test/; HttpOnly\"],\"content-type\":\"text/html;charset=GBK\",\"content-length\":\"128\",\"date\":\"Tue, 01 Sep 2015 12:11:07 GMT\",\"connection\":\"close\"} BODY: &lt;!DOCTYPE&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;GBK page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;GBK编码:&lt;/p&gt; &lt;span&gt;蛤&lt;/span&gt; &lt;/body&gt; &lt;/html&gt;","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://zh-h.github.io/categories/Node-js/"},{"name":"urlencode","slug":"Node-js/urlencode","permalink":"https://zh-h.github.io/categories/Node-js/urlencode/"},{"name":"编码","slug":"Node-js/urlencode/编码","permalink":"https://zh-h.github.io/categories/Node-js/urlencode/编码/"}],"tags":[]},{"title":"802.1x客户端 Openwrt LuCI 开发","slug":"10","date":"2015-10-03T06:35:00.000Z","updated":"2019-10-26T21:49:24.150Z","comments":true,"path":"2015/10/03/10/","link":"","permalink":"https://zh-h.github.io/2015/10/03/10/","excerpt":"","text":"[*] Client: Start. [1] Server: Request Notification![1] Client: Response Notification.[2] Server: Request Identity![2] Client: Response Identity.[3] Server: Request MD5-Challenge![3] Client: Response MD5-Challenge.[4] Server: (H3C private data)[4] Server: Success. 802.1x 目前国内很多大学的校园网安装了基于802.1X认证协议的设备，但是包括华为、实达、锐捷、中兴、星空急速等在内的几家公司全都不提供802.1X客户端的Linux版本，而且…以上是Ubuntu中文wiki发现的坏消息,好在出现了同学们分析协议（iNode协议逆向研究初步入门by tsy），重写移植的客户端，方便了我们的学(zhe)习（teng）伟大的802.1x开源客户端项目1、 njit8021xclient 2、 H3C 802.1x Compatible ClientOpenwrtopenwrt是嵌入式设备上运行的linux系统。 OpenWrt 的文件系统是可写的，开发者无需在每一次修改后重新编译， 令它更像一个小型的 Linux 电脑系统，也加快了开发速度。 你会发现无论是 ARM, PowerPC 或 MIPS 的处理器，都有很好的支持。 并且附带3000左右的软件包，用户可以方便的自定义功能来制作固件。 也可以方便的移植各类功能到openwrt下。从源码编译njit-client on openwrt【详细教程】编译openwrt + njit-client 1.3，通过iNode认证 njit-client在Openwrt平台交叉编译安装傻瓜化步骤(图文)H3C 802.1x Client For OpenWrt 用于OpenWrt的H3C 802.1x认证客户端解决编译过程中的openssl动态链接库问题刷固件我有一个精简的hg255d固件，安装完后还有11.MB的空间，方便以后再折腾更多的软件。lintel的u-boot，网线连接，清空浏览器缓存（防止自动跳转），按下复位键(Rest)再开机，稍等连上电脑出现连接图标，打开192.168.1.1便出现以下界面。然后就按部就班选择固件，点升级，自动刷入重启，几分钟后就能重新连上。默认密码登陆，按照提示设置好ssh密码，network&gt;interface&gt;WAN&gt;Edit&gt;Advance Setting&gt;Override MAC address设置lan覆盖MAC安装软件包附件里有编译好的客户端luci-app-x3c8021xramips.ipk 和依赖包libpcap_1.5.3-1_ramips_24kec.ipk以上软件包均仅支持ramips的cpu，hg255d的r302t在支持范围内。使用WinSCP的SCP模式连接路由器，将两个软件包上传到/root/目录使用快捷键Crtl+P打开PuTTy，ssh登陆，然后使用以下命令按顺序安装软件。opkg install libpcap_1.5.3-1_ramips_24kec.ipkopkg install luci-app-x3c8021xramips.ipk如果安装的时候出现提示架构不兼容的情况，按照以下配置使得opkg可以兼容安装。 编辑\\etc\\opkg.conf在文件末尾添加arch all 100arch ralink 200arch ramips 300arch ramips24kec 400至此安装完成，重启路由器，在network&gt;x3c8021x便可打开设置页面，以下是我的配置，实际使用新版密钥，可以兼容inode 7.0实现连接日志查看LuCI采用了MVC三层架构，同时其使用Lua脚本开发，所以开发LuCI的配置界面不需要编辑任何的Html代码，如果不需要修改视图(view),就不用涉及其他层面。Luci的API文档entry(path, target, title=nil, order=nil)第一个参数是访问的路径，例如{“test”, “hehe”, “2333”}就可以在http://192.168.1.1/cgi-bin/luci/test/hehe/2333访问，在后台添加就需要类似{“admin”, “status”, “syslog”}的参数，在status-&gt;syslog里面显示菜单。第二个参数是目标，有三种直接制定函数，使用call(function)访问指定的页面例如template(“myapp/index”)直接访问/usr/lib/lua/luci/view/myapp/index.html调用模块，使用cbi(“myapp/index”)调用`/usr/lib/lua/luci/model/cbi/myapp/index.lua在这个模块再分发各种请求其他两个参数显而易懂，一个显示名称，一个显示次序（非必需）。照着葫芦画瓢，参考文档在控luci wiki制器/usr/lib/lua/luci/controller/admin/status.lua中尝试着添加这么一个一个入口.function index() entry({“admin”, “status”}, alias(“admin”, “status”, “overview”), (“Status”), 20).index = true entry({“admin”, “status”, “overview”}, template(“adminstatus/index”), (“Overview”), 1) entry({“admin”, “status”, “iptables”}, call(“actioniptables”), (“Firewall”), 2).leaf = true entry({“admin”, “status”, “routes”}, template(“adminstatus/routes”), (“Routes”), 3) entry({“admin”, “status”, “syslog”}, call(“actionsyslog”), (“System Log”), 4) entry({“admin”, “status”, “dmesg”}, call(“actiondmesg”), (“Kernel Log”), 5) entry({“admin”, “status”, “processes”}, cbi(“adminstatus/processes”), (“Processes”), 6) entry({“admin”, “status”, “x3c8021x”}, call(“x3c8021xlog”), (“x3c8021x”), 7) –[[entry({“admin”, “status”, “realtime”}, alias(“admin”, “status”, “realtime”, “load”), _(“Realtime Graphs”), 7)]]––[[省略一段代码,lua的行注释好像就是这么用吧]]–endcall(function)引用声明的一个函数function action_syslog() local syslog = luci.sys.syslog() luci.template.render(“admin_status/syslog”, {syslog=syslog})end–[[照着葫芦画瓢，exec(command)执行一段shell命令，并将命令输出的结果作为返回值返回，依此我们得到日志文件的内容啦，当然根据MVC思想，照样使用原来的视图模板]]–function x3c8021x_log() local x3clog=exec(“cat /tmp/log/x3c8021x.log”) luci.template.render(“admin_status/syslog”, {syslog=x3clog})end因为Luci是随机启动的，接下来需要重启路由使得修改生效， 不过运行的时候出现了问题，这是一个空函数。/usr/lib/lua/luci/dispatcher.lua:448: Failed to execute call dispatcher target for entry ‘/admin/status/x3c8021x’.The called action terminated with an exception:/usr/lib/lua/luci/controller/admin/status.lua:56: attempt to call global ‘exec’ (a nil value)stack traceback: [C]: in function ‘assert’ /usr/lib/lua/luci/dispatcher.lua:448: in function ‘dispatch’ /usr/lib/lua/luci/dispatcher.lua:195: in function &lt;/usr/lib/lua/luci/dispatcher.lua:194&gt;所以使用函数的时候需要加上模块名local x3clog=luci.util.exec(“cat /tmp/log/x3c8021x.log”)重启的时候正好出现不能启动连接的问题，在页面重启之后就看到了日志记录的过程接下来要在X3C8021x的页面添加日志查看的链接\\usr\\lib\\lua\\luci\\model\\cbi\\x3c8021x.lua照葫芦画瓢，添加一个分部，section是和配置文件映射的，所以只能继续沿用。s = m:section(TypedSection, “adv_set”, translate(“Log”))s.anonymous = truel = s:option(Value, “log”, translate(“Auth Log”))l.template = “x3c8012x”l.nocreate = true在\\usr\\lib\\lua\\luci\\view\\添加一个x3c8012x.html视图模板, 视图模板也有执行脚本，所以模型(model)调用的时候也能处理显示数据&lt;div&gt;&lt;pre&gt; …&lt;%=luci.util.exec(“tail -n 20 /tmp/log/x3c8021x.log”) %&gt;&lt;!– tail 是常用的linux命令， tail -n [num]显示文件指定倒数行数的文字 –&gt; &lt;/pre&gt; &lt;/div&gt;&lt;a class=”cbi-button” href=””&gt;Refresh&lt;/a&gt;从此页面可以显示刷新日志信息，关于什么json，实时显示什么的以后再完善吧更新调整启动次序重启路由器的时候，还没有获取到MAC就启动x3cilent就会出现问题。/etc/init.d/x3c8021x 修改START=50为START=99，这是启动脚本的优先级，不能超过100.////////////////////////////////////////////&nbsp;下载1：附件&nbsp;////////////////////&nbsp;下载2：附件&nbsp;///////////////////////////////////////////","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://zh-h.github.io/tags/Linux/"},{"name":"lua","slug":"lua","permalink":"https://zh-h.github.io/tags/lua/"},{"name":"openwrt","slug":"openwrt","permalink":"https://zh-h.github.io/tags/openwrt/"}]},{"title":"Windows 10更改标题栏","slug":"12","date":"2015-09-03T06:39:00.000Z","updated":"2019-10-26T21:49:24.151Z","comments":true,"path":"2015/09/03/12/","link":"","permalink":"https://zh-h.github.io/2015/09/03/12/","excerpt":"","text":"苍白标题栏拜拜，改回彩色标题栏~~~ Windows &gt; Resources &gt; Themes 复制一份areo.theme，中途提示跳过，然后改名为color.theme 把里面的包含areo的文件名都改成color 把reo用文本编辑器打开，把里面的路径areo也改成color 双击color.theme应用主题","categories":[{"name":"默认分类","slug":"默认分类","permalink":"https://zh-h.github.io/categories/默认分类/"},{"name":"windows","slug":"默认分类/windows","permalink":"https://zh-h.github.io/categories/默认分类/windows/"}],"tags":[]},{"title":"Hello World ! golang 并没有 while true, do while 语法","slug":"22","date":"2015-08-16T03:17:00.000Z","updated":"2019-10-26T21:49:24.155Z","comments":true,"path":"2015/08/16/22/","link":"","permalink":"https://zh-h.github.io/2015/08/16/22/","excerpt":"","text":"console.log(‘Hello World!’);","categories":[{"name":"默认分类","slug":"默认分类","permalink":"https://zh-h.github.io/categories/默认分类/"},{"name":"go","slug":"默认分类/go","permalink":"https://zh-h.github.io/categories/默认分类/go/"}],"tags":[]},{"title":"SQL去重问题","slug":"34","date":"2015-07-10T00:54:00.000Z","updated":"2019-10-26T21:49:24.156Z","comments":true,"path":"2015/07/10/34/","link":"","permalink":"https://zh-h.github.io/2015/07/10/34/","excerpt":"","text":"问题：前期开发的需求没有对某个数据表的某个字段进行唯一性校验，现在需要把有重复的数据行合并到一起， 并且重复数据中取ID最大的一条创建表123456CREATE TABLE `user` ( `id` INT(11) NOT NULL, `username` VARCHAR(50) NULL DEFAULT NULL, `email` VARCHAR(50) NULL DEFAULT NULL, PRIMARY KEY (`id`)) 表中插入的数据12345678+----+----------+------------------+| id | username | email |+----+----------+------------------+| 1 | zonghua | zh.h@outlook.com || 2 | lala | zh.h@outlook.com || 3 | yoyo | yoyo@outlook.com || 4 | coco | coco@outlook.com |+----+----------+------------------+ 表中的第一和第二行的email重复，在使用emial确定唯一身份的情况下，去掉第一行或者第二行。 方法1 把用户表按照email分组（或者组合其他条件分组）取每组id最大的id； 把原来用户表左关联到id最大的虚拟表，即b； 关联后右边没有的id就是两表的差集，即重复email但id不是最大的行； 123select a.id from `user` a left join (select max(id) as `id`, email from `user` group by email) b on a.id = b.id where isnull(b.id) 或者直接用in查询； 1234select id from `user` where id not in(select id from (select max(id) id, email from `user` group by email) as b) 得到。12345+----+----------+------------------+| id | username | email |+----+----------+------------------+| 1 | zonghua | zh.h@outlook.com |+----+----------+------------------+ 把重复数据id存入临时表； 12345create table temp_user as (select a.id from `user` a left join (select max(id) as `id`, email from `user` group by email) b on a.id = b.id where isnull(b.id)) 然后删除； 1delete from `user` where id in (select id from `temp_user`) 结果。 1234567+----+----------+------------------+| id | username | email |+----+----------+------------------+| 2 | lala | zh.h@outlook.com || 3 | yoyo | yoyo@outlook.com || 4 | coco | coco@outlook.com |+----+----------+------------------+ MySQL 语句执行顺序 FORM: 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1 ON: 对虚表VT1进行ON筛选，只有那些符合的行才会被记录在虚表VT2中。 JOIN： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, rug from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。 WHERE： 对虚拟表VT3进行WHERE条件过滤。只有符合的记录才会被插入到虚拟表VT4中。 GROUP BY: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5. CUBE | ROLLUP: 对表VT5进行cube或者rollup操作，产生表VT6. HAVING： 对虚拟表VT6应用having过滤，只有符合的记录才会被 插入到虚拟表VT7中。 SELECT： 执行select操作，选择指定的列，插入到虚拟表VT8中。 DISTINCT： 对VT8中的记录进行去重。产生虚拟表VT9. ORDER BY: 将虚拟表VT9中的记录按照进行排序操作，产生虚拟表VT10. LIMIT：取出指定行的记录，产生虚拟表VT11, 并将结果返回。 注意项1. distinct的唯一是select所有字段的组合条件2. group by 条件必须在 select 里面3. 先group by后order by4. exist是做真值判断，in是形成虚拟表5. in后面只能有一个字段 分组聚合分组统计具有同名部门的部门名称+ID、员工总数、最低薪水、最高薪水、薪水总计。 123select concat(d.name, '-',d.id), count(u.id), min(u.salary), max(u.salary), sum(u.salary)from `department` d left join `user` u on d.id = u.department_idgroup by d.id, d.name","categories":[{"name":"默认分类","slug":"默认分类","permalink":"https://zh-h.github.io/categories/默认分类/"},{"name":"sql","slug":"默认分类/sql","permalink":"https://zh-h.github.io/categories/默认分类/sql/"}],"tags":[]},{"title":"比尔·盖茨：苹果只为牟利，比特币大有前途，Office是人类的希望","slug":"8","date":"2014-08-18T06:32:00.000Z","updated":"2019-10-26T21:49:24.159Z","comments":true,"path":"2014/08/18/8/","link":"","permalink":"https://zh-h.github.io/2014/08/18/8/","excerpt":"","text":"比尔·盖茨10月初接受了彭博电视台的采访。 无可否认的事实，比尔·盖茨是一个非常聪明的人，他 不仅对技术也为热情帮助穷人通过他的比尔梅琳达·盖茨基金会。今天，他坐下来与彭博电视埃里克Schatzker探讨了很多话题，从银行为穷人萨蒂亚纳德拉是怎么做的，在微软他是否会花时间球场边观看快船队与他的朋友，史蒂夫·鲍尔默。 在采访的开始，盖茨谈到他如何努力让银行为穷人服务。提供了一些想法和原因，银行对穷人是很重要的，他说，比特币，或未来类似的技术，将是一个伟大的路要走。 “比特币之所以令人兴奋，是因为人们发现它可以如此廉价。比特币比现金要好。因为你无需将钱存放在某处，尤其大量现金的流通会相当不便。我们所讨论的客户并非籍籍无名，他们渴望成名，而比特币技术就是关键。我们可以将类似技术应用于人们比较放心的领域，它与恐怖主义或洗钱无关。” 话题转到了Apple Pay，以及如何利用它进行小额交易。尽管比尔·盖茨热衷扶贫慈善事业，但谈起这项技术他还是很兴奋，认为苹果能将之带给全世界很多普通用户为的就是更好地牟利。 移动电话强力驱动其用户进行原本会超级昂贵的交易，Apple Pay就是典型的例子。 因此，事实上，在任何应用程序，我可以买的东西，这是梦幻般的。 我不需要实物卡了一个事实，我只是做了交易，而你将是十分清楚是谁在另一端，这是一个真正的贡献，和所有的平台无论是苹果的或谷歌的还是微软的，你会看到这样的支付能力得到建，这是建立在行业标准协议，NFC，而这些公司都参与了获得这些准备，苹果将帮助确保它得到了临界点为所有的设备。 主持人接着问盖茨，如果他跟蒂姆·库克如何帮助有此举措。 盖茨有点心慌了，基本上可以说是大家都知道苹果一切都是为了牟利。 “不……内个……呃……真正的事实并非苹果所带动所致。如果人们为支付设备签署了协议，任何人都会用Apple Pay，因此他们不陷入了苹果的陷坑。” 随后，主持人再次令盖茨难堪，他指出，盖茨所谈的电子支付功能，在他自己20年前写的一本书《未来之路》（The Road Ahead）中就讨论过。问题就开始无趣了：“微软为什么会没有进入支付市场？”盖茨显得有些不爽，咧嘴笑了好久，给出的回答简直跟没说一样。 “嗯，微软有很多存款，它可以利用其技术来做这事儿。至于通过较好的密保方式来进行支付和储蓄的能力，所有平台都在做。因此，愿景，微软在这一方面一个很好的愿景，我的时间在这方面的所有基金会的重点” 谈话然后切换到新的微软CEO萨蒂亚纳德拉。 虽然盖茨表示，他“非常高兴自己在做什么，”好奇他接着说，他认为该公司需要做出的Microsoft Office是人类的希望。 我们不知道到底是什么意思，但盖茨非常确定地认为公司应当采纳他的意见。 当然，微软应该做的一样好或更好，但所有的事情微软需要做决策的人在他们的工作更有成效方面，帮助他们以新的方式进行通信。 这是一个长长的清单机遇微软有创新， 并上台并使其显着提高将是非常高的就行了，这就是我正在努力，以确保他们移动快上之类的话 。 我很高兴自己在做什么。 我看到新的能量感。 有很多机会的出现。 有些东西该公司是不是在领导者，他认为他需要改变这种状况。 谈话结束之前，还有一个关于他是否会为即将到来的老朋友鲍尔默的快船队比赛助威的话题。 “我不是那种花大量时间去看运动比赛的人，但既然我的老朋友是球队老板，而我又乐意花时间与他们相处，所以我应该回去凑热闹大气吧” 总体而言，这是一个有趣的采访，绝对值得观看的时候，即使重点提高的Microsoft Office让我们吃惊不少。","categories":[{"name":"默认分类","slug":"默认分类","permalink":"https://zh-h.github.io/categories/默认分类/"}],"tags":[]}]}